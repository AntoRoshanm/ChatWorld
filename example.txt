  // const sendEmail = (e) => {
  //   e.preventDefault();

  //   emailjs.sendForm('service_nzmmaeh', 'template_ez6erhr', form.current, 'y9Y6hpiZoJRKN-Pd0')
  //     .then((result) => {
  //         console.log(result.text);
  //     }, (error) => {
  //         console.log(error.text);
  //     });
  // };

  // const sendEmail = () => {
  //   const formData = {
  //     name: username,
  //     email: EmailId,
  //     message: `Password: ${Password}`,
  //   };

  //   emailjs.send('service_nzmmaeh', 'template_ez6erhr', formData, 'y9Y6hpiZoJRKN-Pd0')
  //     .then((result) => {
  //       console.log(result.text);
  //     })
  //     .catch((error) => {
  //       console.log(error.text);
  //     });
  // };

  // const sendEmail = () => {
  //   const formData = {
  //     name: username,
  //     email: EmailId,
  //     message: `Password: ${Password}`,
  //   };
  //   emailjs.send('service_nzmmaeh', 'template_ez6erhr', formData, 'y9Y6hpiZoJRKN-Pd0')
  //     .then((result) => {
  //       console.log(result.text);
  //     })
  //     .catch((error) => {
  //       console.log(error.text);
  //     });
  // };

//   const sendMail = () => {
//     Mailer.mail({
//       subject: 'React Native Mail',
//       recipients: ["d2.3antoroshan@gmail.com"],
//       body: 'This is the email body.',
//       isHTML: true,
//     }, (error, event) => {
//       if(error) {
//         Alert.alert('Error', 'Could not send mail.');
//       } else {
//         Alert.alert('Success', 'Mail sent successfully.');
//       }
//     });
//  };
   

// const sendEmail = async () => {
//   try {
//     const response = await SMTPMailer.sendMail({
//       mailhost: 'smtp.gmail.com',
//       port: 465, // Use 465 for secure SSL/TLS connection
//       ssl: true, // Use SSL/TLS
//       username: 'ChatWorld2003@gmail.com',
//       password: 'ChatWorld@260703',
//       from: 'ChatWorld2003@gmail.com',
//       recipients: `${EmailId}`,
//       subject: 'Test Email',
//       htmlBody: '<p>This is a test email.</p>',
//     });

//     console.log(response);
//     // Check the response for success or error information
//   } catch (error) {
//     console.error(error);
//   }
// };

//     const formData = {
//       name: username,
//       email: EmailId,
//       message: `Password: ${Password}`,
//     };

// const sendEmail = () => {

//   emailjs
//     .sendForm(
//       'service_nzmmaeh',
//       'template_ez6erhr',
//       formData.current,
//       'y9Y6hpiZoJRKN-Pd0',
//     )
//     .then(
//       result => {
//         console.log(result.text);
//       },
//       error => {
//         console.log(error.text);
//       },
//     );
// };


// const handleSendOTP = async () => {
//   try {
//     const response = await axios.post('http://192.168.1.23/send-otp', { EmailId });
//     if (response.data.success) {
//       Alert.alert('Success', 'OTP sent successfully.');
//     } else {
//       Alert.alert('Error', response.data.error);
//     }
//   } catch (error) {
//     console.error('Error sending OTP:', error.message);
//     Alert.alert('Error', 'Failed to send OTP.');
//   }
// };
   
const sendEmail = async (to, subject, body) => {
  const url = `mailto:${to}?subject=${subject}&body=${body}`;

  // Check if email app is available
  const canOpen = await Linking.canOpenURL(url);

  if (!canOpen) {
    throw new Error('No email app found');
  }

  // Open email app with pre-filled content
  await Linking.openURL(url);
};

// Example usage

  // const sendOtp = () => {
  //   fetch("http://192.168.1.18:2000/verify", {
  //     method: "POST",
  //     headers: {
  //         Accept: 'application/json',
  //         'Content-Type': 'application/json',
  //     },
  //     body: JSON.stringify({
  //         Password
  //     })
  // })
  //     .then(res => res.json())
  //     .then(json => {
  //         if (json.success) {
  //             // navigation.navigate("VerificationForm", {  })
  //         }
  //         else {
  //             Alert.alert("Error", "Could not sign up");
  //         }
  //     })
  //     .catch(e => {
  //         Alert.alert("Error", "Could not sign up");
  //     })
  // };

  // const verify = () =>{
  //   fetch("http://192.168.1.18:2000/register", {
  //     method: "POST",
  //     headers: {
  //         Accept: 'application/json',
  //         'Content-Type': 'application/json',
  //     },
  //     body: JSON.stringify({
  //         Password: Password,
  //         code: code
  //     })
  // })
  //     .then(res => res.json())
  //     .then(json => {
  //         if (json.success) {
  //             // navigation.navigate("Dashboard")
  //         }
  //         else {
  //             Alert.alert("Error", "Could not sign up");
  //         }
  //     })
  //     .catch(e => {
  //         Alert.alert("Error", "Could not sign up");
  //     })
  // }

  // const express = require('express');
// var bodyParser = require('body-parser')
// const textflow = require("textflow.js")

// textflow.useKey("duKwiUvQyEkCJV4AK1UyutMtUevgNMkASKt1LIFhtrWYsxkS9zGRwDy6CjB4yxXl")

// const app = express();

// app.use(bodyParser.json())
// app.use(bodyParser.urlencoded({ extended: true }));

// app.post("/register", async (req, res) => {
//   const { Password, code } = req.body

//   var result = await textflow.verifyCode(Password, code);

//   if(!result.valid){
//       return res.status(400).json({ success: false });
//   }
// })

// app.post("/verify", async (req, res) => {
//   const { Password } = req.body

//   var result = await textflow.sendVerificationSMS(Password);

//   if (result.ok) 
//     return res.status(200).json({ success: true });

//   return res.status(400).json({ success: false });
// })

// app.listen(2000);


// const express = require('express');
// const bodyParser = require('body-parser');
// const twilio = require('twilio');

// const app = express();

// app.use(bodyParser.json());

// app.post('/send-sms', async (req, res) => {
//   const { Password } = req.body;

// const accountSid = "AC33206b0cdcf401e5b2e7e9e05ba89a62";
// const authToken = "30ba8937ff17c7d7d5ea7f2676d79021";
// const verifySid = "VAdf23756db641ec4f8255ad3a058c9e08";
// const client = require("twilio")(accountSid, authToken);

// client.verify.v2
//   .services(verifySid)
//   .verifications.create({ to: `${Password}`, channel: "sms" })
//   .then((verification) => {
//     console.log(verification.status)
//     res.json({ otpStatus: verification.status });
//   })
//   .then(() => {
//     const readline = require("readline").createInterface({
//       input: process.stdin,
//       output: process.stdout,
//     });
//     readline.question("Please enter the OTP:", (otpCode) => {
//       client.verify.v2
//         .services(verifySid)
//         .verificationChecks.create({ to: `${Password}`, code: otpCode })
//         .then((verification_check) => console.log(verification_check.status))
//         .then(() => readline.close());
//     });
//   });
// });


// app.post('/verify', async (req, res) => {
//   const { Password } = req.body;

//   const accountSid = "AC33206b0cdcf401e5b2e7e9e05ba89a62";
//   const authToken = "30ba8937ff17c7d7d5ea7f2676d79021";
//   const verifySid = "VAdf23756db641ec4f8255ad3a058c9e08";
//   const client = require("twilio")(accountSid, authToken);

//   // Send OTP to the provided phone number
//   client.verify.v2
//     .services(verifySid)
//     .verifications.create({ to: `${Password}`, channel: "sms" })
//     .then((verification) => {
//       console.log(verification.status);

//       // Send the OTP back to the client as a response
//       res.json({ otpStatus: verification.status });
//     })
//     .catch((error) => {
//       console.error(error);
//       res.status(500).json({ error: 'Internal Server Error' });
//     });
// });




// app.listen(3000, () => console.log('Server listening on port 3000'));





// server.js


  // const sendOtp = async() => {
  //   const response = await fetch('http://192.168.1.3:3000/send-sms', {
  //     method: 'POST',
  //     headers: {
  //       'Content-Type': 'application/json',
  //     },
  //     body: JSON.stringify({
  //       Password,
  //     }),
  //   });
  //   const data = await response.json();

  //   if (data.message) {
  //     Alert.alert('Message sent successfully!');
  //   } else {
  //     Alert.alert(data.error);
  //   }
  // };

  // const verify = () => {
  //   // Make a request to your server to send OTP
  //   fetch('http://192.168.1.3:3000/verify', {
  //     method: 'POST',
  //     headers: {
  //       'Content-Type': 'application/json',
  //     },
  //     body: JSON.stringify({ Password }), // Replace 'userPhoneNumber' with the actual phone number
  //   })
  //     .then(response => response.json())
  //     .then(data => {
  //       // Handle the response from the server
  //       console.log(data);

  //       // Assuming the server sends otpStatus in the response
  //       if (data.otpStatus === 'pending') {
  //         // OTP sent successfully, you can update the UI or take further actions
  //         navigation.navigate('MainPages')
  //       } else {
  //         // Handle other cases if needed
  //       }
  //     })
  //     .catch(error => {
  //       console.error('Error:', error);
  //       // Handle errors if needed
  //     });
  // };


    // const todoRef = firebase.firestore().collection('ChatWorld');
  // const addField = () => {
  //   // check if we have new field data
  //   if (
  //     // username &&
  //     // username.length > 0 &&
  //     EmailId &&
  //     EmailId.length > 0 &&
  //     Password &&
  //     Password.length > 0 &&
  //     userPassword &&
  //     userPassword.length > 0
  //   ) {
  //     // get the timestamp
  //     const timestamp = firebase.firestore.FieldValue.serverTimestamp();
  //     const data = {
  //       // username: username,
  //       EmailId: EmailId,
  //       Password: Password,
  //       userPassword:userPassword,
  //       createdAt: timestamp,
  //     };
  //     todoRef
  //       .add(data)
  //       .then(() => {
  //         // setUsername('');
  //         setEmailId('');
  //         setPassword('');
  //         setuserPassword('')
  //         // Keyboard.dismiss();
  //       })
  //       .catch(error => {
  //         alert(error);
  //       });
  //   }
  // };

//   const loginData = () => {
//     // Authenticate the user using Firebase Authentication
//     firebase
//       .auth()
//       .signInWithEmailAndPassword(UserID, userPassword)
//       .then((userCredential) => {
//         // Signed in
//         const user = userCredential.user;
//         console.log('User signed in:', user);

//         // Navigate to the main page after successful login
//         navigation.navigate('MainPages');
//       })
//       .catch((error) => {
//         // Handle errors such as invalid email or wrong password
//         const errorCode = error.code;
//         const errorMessage = error.message;
//         console.error('Error signing in:', errorCode, errorMessage);

//         // Display an alert to the user
//         Alert.alert('Login Error', 'Invalid email or password. Please try again.');
//       });
//   };
// const todoRef = firebase.firestore().collection('ChatWorld');
// const handleLogin = async() => {
//   if (
//     UserID &&
//     UserID.length > 0 &&
//     userPassword &&
//     userPassword.length > 0
//   ) {
//     // Check if the user with the same email already exists
//     await todoRef
//       .where('UserID', '==', UserID)
//       .where('userPassword', '==', userPassword)
//       .get()
//       .then((querySnapshot) => {
//         if (!querySnapshot.empty) {
//           // User with the same email already exists
//           // Alert.alert('User with this email already exists');
//           navigation.navigate('UserSetupPage');
//         } else {
//           // User does not exist, proceed to add the data
//           // const timestamp = firebase.firestore.FieldValue.serverTimestamp();
//           // const data = {
//           //   UserID: UserID,
//           //   Password: Password,
//           //   userPassword: userPassword,
//           //   createdAt: timestamp,
//           // };
//           Alert.alert("User is invalid Check UserId & Password or Register")
//         }
//       })
//       .catch((error) => {
//         alert(error);
//       });
//   }
//  };


  // const handleOption1 = async() => {
  //   closeModal();
  //   ImagePicker.openCamera({
  //     compressImageMaxWidth: 300,
  //     compressImageMaxHeight: 400,
  //     cropping: true,
  //     compressImageQuality:0.7,
  //   }).then(async (image) => {
  //     console.log(image);
  //     setImageUrl(image.path)
  //     await uploadProfilePhoto();
  //   });
  // };

  // const handleOption2 = () => {
  //   closeModal();
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 300,
  //     compressImageMaxHeight: 400,
  //     compressImageQuality:0.7,
  //     cropping: true
  //   }).then(image => {
  //     console.log(image);
  //     setImageUrl(image.path)
  //   });
  // };


  // const { UserID, userPassword } = route.params;

  // const uploadProfilePhoto = async () => {
  //   try {
  //     // Upload the image to Firebase Storage
  //     const response = await fetch(imageUrl);
  //     const blob = await response.blob();
  
  //     // Determine the file extension based on the image format
  //     const fileExtension = imageUrl.split('.').pop().toLowerCase(); // Extract the file extension
  //     const storagePath = `profile_photos/${UserID}.${fileExtension}`;
  
  //     const storageRef = firebase.storage().ref();
  //     const imageRef = storageRef.child(storagePath);
  //     await imageRef.put(blob);
  
  //     // Get the download URL of the uploaded image
  //     const downloadURL = await imageRef.getDownloadURL();
  
  //     // Store user data in Firestore, including the download URL
  //     const userRef = firebase.firestore().collection('ChatWorld').doc(UserID);
  
  //     // Check if the document exists before updating
  //     const userDoc = await userRef.get();
  
  //     if (userDoc.exists) {
  //       // Update existing document
  //       await userRef.update({
  //         profilePhoto: downloadURL,
  //       });
  //     } else {
  //       // Create a new document with the specified data
  //       await userRef.set({
  //         UserID: UserID,
  //         userPassword: userPassword,
  //         profilePhoto: downloadURL,
  //       });
  //     }
  
  //     // Uncomment the following line if you want to navigate to another screen
  //     // navigation.navigate('MainPages');
  //   } catch (error) {
  //     console.error('Error uploading image:', error);
  //   }
  // };

            <TouchableOpacity>
              <Entypo name="plus" size={25} color="black" style={styles.iconss} />
            </TouchableOpacity>



      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {message.text && (
              <Text style={styles.messageText}>{message.text}</Text>
            )}
            {message.image && (
              <Image
                source={{uri: message.image}}
                style={styles.image}
                resizeMode="cover"
              />
            )}
          </View>
        ))}
      </ScrollView> 


  // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });

  //     // Handle the picked document here, e.g., set the document URL in state
  //     console.log(result.uri);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       // User cancelled the document picker
  //       console.log('Document picking cancelled');
  //     } else {
  //       // Handle other errors
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };

  // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });

  //     // Set the selected document in state
  //     setSelectedDocument(result);
  //     console.log(result.uri);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };

  // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });
  
  //     // Handle the picked document here, e.g., set the document URL in state
  //     console.log(result.uri);
  //     const newDocument = {
  //       name: result.name,
  //       size: result.size,
  //       uri: result.uri,
  //     };
  //     setSelectedDocuments([...selectedDocuments, newDocument]);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };  

{Math.round(document.size / 1024)} KB



      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {/* ... (previous message components) */}
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <View key={docIndex} style={styles.documentContainer}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {message.name} ({message.size.toFixed(2)} GB)
                    </Text>
                  </View>
                </View>
              ))}
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <View key={index} style={styles.messageContainer}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName}>{document.name}</Text>
                <Text style={styles.documentSize}>
                  {Math.round(document.size / 1024)} KB
                </Text>
              </View>
            </View>
            <Text style={styles.messageText}>{document.uri}</Text>
          </View>
        ))}
      </ScrollView>




https://github.com/ivpusic/react-native-image-crop-picker


import React, {useState, useEffect} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  ScrollView,
  Keyboard,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';

const GlobalChatScreen = ({navigation}) => {
  const [inputText, setInputText] = useState('');
  const [messages, setMessages] = useState([]);
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setIsKeyboardOpen(true);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setIsKeyboardOpen(false);
      },
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const sendMessage = () => {
    // Add the new message to the messages state
    setMessages([...messages, inputText]);
    // Clear the input field
    setInputText('');
  };

  return (
    <KeyboardAvoidingView behavior="padding" style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back-outline" size={30} color="black" />
        </TouchableOpacity>
        <TouchableOpacity>
          <Ionicons name="videocam-outline" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            <Text style={styles.messageText}>{message}</Text>
          </View>
        ))}
      </ScrollView>
      <View style={styles.inputContainer}>
        {!isKeyboardOpen && (
          <TouchableOpacity style={styles.cameraicon}>
            <Ionicons name="camera" size={25} color="black" />
          </TouchableOpacity>
        )}
        <TextInput
          style={styles.textInput}
          placeholder="Type your message..."
          value={inputText}
          onChangeText={setInputText}
        />
        {isKeyboardOpen ? (
          <View>
            <TouchableOpacity
              onPress={sendMessage}
              style={styles.sendiconbutton}
              disabled={inputText.trim().length === 0}>
              <Entypo name="paper-plane" size={30} color="black" />
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <TouchableOpacity>
              <Entypo name="plus" size={25} color="black" style={styles.icon} />
            </TouchableOpacity>
            <TouchableOpacity>
              <Ionicons
                name="mic-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
            <TouchableOpacity>
              <Ionicons
                name="image-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
          </>
        )}
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  contentContainer: {
    flexGrow: 1,
    backgroundColor: 'white',
  },
  messageContainer: {
    padding: 8,
    marginVertical: 4,
    borderRadius: 8,
    backgroundColor: 'pink',
    maxWidth: '80%',
    alignSelf: 'flex-end',
  },
  messageText: {
    fontSize: 16,
    color: 'black',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'lightgray',
    padding: 10,
    backgroundColor: 'white',
  },
  textInput: {
    height: 40,
    borderWidth: 1,
    width: '60%',
    borderColor: 'gray',
    borderRadius: 20,
    padding: 8,
    marginHorizontal: 5,
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  sendiconbutton: {
    padding: 10,
    marginLeft: 15,
  },
  icon: {
    marginHorizontal: 5,
  },
  iconss:{
    padding: 10,
  },
  plusIcon: {
    marginRight: 15,
  },
});

export default GlobalChatScreen;



      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {/* ... (previous message components) */}
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <TouchableOpacity
                  key={docIndex}
                  style={styles.documentContainer}
                  onPress={() => openModal(document)}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {message.name} ({message.size.toFixed(2)} GB)
                    </Text>
                  </View>
                </TouchableOpacity>
              ))}
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <TouchableOpacity
            key={index}
            style={styles.messageContainer}
            onPress={() => openModal(document)}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName}>{document.name}</Text>
                <Text style={styles.documentSize}>
                  {Math.round(document.size / 1024)} KB
                </Text>
              </View>
            </View>
            <Text style={styles.messageText}>{document.uri}</Text>
          </TouchableOpacity>
        ))}
      </ScrollView>


        // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });
  //     console.log(result.uri);
  //     const newDocument = {
  //       name: result.name,
  //       size: result.size ? result.size / (1024 * 1024 * 1024) : 0,
  //       uri: result.uri,
  //     };
  //     setSelectedDocuments([...selectedDocuments, newDocument]);
  //     console.log('Selected documents updated:', selectedDocuments);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };

  // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });

  //     console.log('Document URI:', result.uri);
  //     console.log('Document Name:', result.name);
  //     console.log('Document Size:', result.size);

  //     const newDocument = {
  //       name: result.name || 'Untitled', // Use a default name if result.name is undefined
  //       size: result.size ? result.size / (1024 * 1024 * 1024) : 0,
  //       uri: result.uri || 'Unknown URI', // Use a default URI if result.uri is undefined
  //     };

  //     setSelectedDocuments([...selectedDocuments, newDocument]);
  //     console.log('Selected documents updated:', selectedDocuments);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };


  // const pickDocument = async () => {
  //   try {
  //     const result = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });
  
  //     console.log('Document Result:', result);
  
  //     const newDocument = {
  //       name: result.name || 'Untitled',
  //       size: result.size ? result.size / (1024 * 1024 * 1024) : 0,
  //       uri: result.uri || 'Unknown URI',
  //     };
  
  //     setSelectedDocuments([...selectedDocuments, newDocument]);
  //     console.log('Selected documents updated:', selectedDocuments);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };

    // const pickDocument = async () => {
  //   try {
  //     const [result] = await DocumentPicker.pick({
  //       type: [DocumentPicker.types.allFiles],
  //     });

  //     console.log('Complete Document Result:', result);

  //     // Log specific properties to check their values
  //     console.log('Document Name:', result.name);
  //     console.log('Document Size:', result.size);
  //     console.log('Document URI:', result.uri);

  //     const newDocument = {
  //       name: result.name || 'Untitled',
  //       size: result.size ? result.size / (1024 * 1024) : 0, // Adjusted size calculation
  //       uri: result.uri || 'Unknown URI',
  //     };

  //     setSelectedDocuments([...selectedDocuments, newDocument]);
  //     console.log('Selected documents updated:', selectedDocuments);
  //   } catch (err) {
  //     if (DocumentPicker.isCancel(err)) {
  //       console.log('Document picking cancelled');
  //     } else {
  //       console.error('Error picking document:', err);
  //     }
  //   }
  // };

  // const formatFileSize = sizeInBytes => {
  //   if (sizeInBytes < 1024) {
  //     return sizeInBytes.toFixed(2) + ' B';
  //   } else if (sizeInBytes < 1024 * 1024) {
  //     return (sizeInBytes / 1024).toFixed(2) + ' KB';
  //   } else if (sizeInBytes < 1024 * 1024 * 1024) {
  //     return (sizeInBytes / (1024 * 1024)).toFixed(2) + ' MB';
  //   } else {
  //     return (sizeInBytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
  //   }
  // };

        {/* <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {message.text && (
              <Text style={styles.messageText}>{message.text}</Text>
            )}
            {message.image && (
              <Image
                source={{uri: message.image}}
                style={styles.image}
                resizeMode="cover"
              />
            )}
          </View>
        ))}
      </ScrollView>  */}

             // setGalleryImages(images.map(image => image.path));


                 // onSendMessage(imageUrl);
    // const allImages = [imageUrl, ...galleryImages];

    
buildscript {
    ext.getExtOrDefault = {name ->
        return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.ext.get(name)
    }
    
    ext {
        gradleVersion = '4.1.0'
        kotlinVersion = '1.6.0'
    }

    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        classpath "com.android.tools.build:gradle:4.2.2"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${getExtOrDefault('kotlinVersion')}"
    }
}

def safeExtGet(prop, fallback) {
    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
}

apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'

android {
  def agpVersion = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION
  if (agpVersion.tokenize('.')[0].toInteger() >= 7) {
    namespace "com.dooboolab.audiorecorderplayer"
  }
  compileSdkVersion safeExtGet('compileSdkVersion', 31)

  defaultConfig {
    minSdkVersion safeExtGet('minSdkVersion', 24)
    targetSdkVersion safeExtGet('targetSdkVersion', 31)
    versionCode 1
    versionName "1.0"
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  lintOptions {
    abortOnError false
  }
}

repositories {
    mavenCentral()
}

dependencies {
  implementation 'com.facebook.react:react-native:+'
  implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:${safeExtGet('kotlinVersion', project.ext.kotlinVersion)}"

  def supportLibVersion = safeExtGet('supportLibVersion', safeExtGet('supportVersion', null))
  def androidXVersion = safeExtGet('androidXVersion', null)
  if (supportLibVersion && androidXVersion == null) {
    implementation "com.android.support:support-annotations:$supportLibVersion"
    implementation "com.android.support:customtabs:$supportLibVersion"
  } else {
    def defaultAndroidXVersion = "1.2.0"
    if (androidXVersion == null) {
      androidXVersion = defaultAndroidXVersion
    }
    def androidXAnnotation = safeExtGet('androidXAnnotation', androidXVersion)
    def androidXBrowser = safeExtGet('androidXBrowser', androidXVersion)
    implementation "androidx.annotation:annotation:$androidXAnnotation"
    implementation "androidx.browser:browser:$androidXBrowser"
  }
}


       <View style={styles.inputContainer}>
      {!isKeyboardOpen && (
        <TouchableOpacity
          style={styles.cameraicon}
          onPress={usertextCamera}>
          <Ionicons name="camera" size={25} color="black" />
        </TouchableOpacity>
      )}
      <TextInput
        style={styles.textInput}
        placeholder="Type your message..."
        value={inputText}
        onChangeText={setInputText}
      />
      {isKeyboardOpen ? (
        <View style={{ flexDirection: 'row' }}>
          {isRecording ? (
            <TouchableOpacity onPress={stopRecording}>
              <Ionicons
                name="stop-circle-outline"
                size={30}
                color="red"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
          ) : (
            <TouchableOpacity onPress={startRecording}>
              <Ionicons
                name="mic-outline"
                size={25}
                color="black"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
          )}
          {/* ... other buttons */}
        </View>
      ) : (
        <View></View>
      )}
    </View>

      // const startRecording = async () => {
  //   try {
  //     const granted = await PermissionsAndroid.request(
  //       PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
  //       {
  //         title: 'Record Audio Permission',
  //         message: 'App needs access to your microphone to record audio',
  //         buttonPositive: 'OK',
  //       },
  //     );

  //     if (granted === PermissionsAndroid.RESULTS.GRANTED) {
  //       const path = RNFS.DocumentDirectoryPath + '/audio/file.mp4'; // Modify the path
  //       await RNFS.mkdir(RNFS.DocumentDirectoryPath + '/audio'); // Create the directory
  //       await audioRecorderPlayer.startRecorder(path);
  //       setIsRecording(true);
  //     } else {
  //       console.warn('Record audio permission denied');
  //     }
  //   } catch (error) {
  //     console.error('Error starting recording:', error);
  //   }
  // };

  // const stopRecording = async () => {
  //   try {
  //     const result = await audioRecorderPlayer.stopRecorder();
  //     setIsRecording(false);

  //     // Assuming you want to send the recorded audio file as a message
  //     if (result) {
  //       const newMessage = {
  //         audio: result,
  //       };
  //       setMessages([...messages, newMessage]);
  //     }
  //   } catch (error) {
  //     console.error('Error stopping recording:', error);
  //   }
  // };

  // const playAudio = async (audioPath) => {
  //   try {
  //     await audioPlayer.current.startPlayer(audioPath);
  //   } catch (error) {
  //     console.error('Error playing audio:', error);
  //   }
  // };

  // useEffect(() => {
  //   // Clean up audio player when component unmounts
  //   return () => {
  //     audioPlayer.current.stopPlayer();
  //   };
  // }, []);

          {audioUri ? (
          <View style={styles.audioPlaybackContainer}>
            <AudioWaveform
              style={{height: 40}}
              source={{uri: audioUri}}
              autoPlay={false} // Set to true if you want the audio to play automatically
              color="#BFBFBF" // Waveform color
              progressColor="#000000" // Progress color
              gapColor="#FFFFFF" // Gap color
              play={isPlaying} // Play/pause control
            />
            <View
              style={{
                flexDirection: 'row',
                justifyContent: 'space-between',
                alignItems: 'center',
              }}>
              <Text>
                {audioRecorderPlayer.mmssss(
                  audioRecorderPlayer.convertTime(
                    audioRecorderPlayer.getRecordTime(),
                  ),
                )}
              </Text>
              <TouchableOpacity onPress={playRecording}>
                <Ionicons
                  name={isPlaying ? 'pause' : 'play'}
                  size={30}
                  color="#BFBFBF"
                  style={styles.micplayicon}
                />
              </TouchableOpacity>
            </View>
          </View>
        ) : null}

          // const stopRecording = async () => {
  //   try {
  //     const result = await audioRecorderPlayer.stopRecorder();
  //     setIsRecording(false);
  //     setAudioUri(result);
  //     console.log(result);
  //   } catch (error) {
  //     console.error('Error stopping recording:', error);
  //   }
  // };

  // const playRecording = async () => {
  //   try {
  //     console.log('Audio URI:', audioUri);
  
  //     // Check if audioUri is available
  //     if (!audioUri) {
  //       console.error('Audio URI is empty or undefined.');
  //       return;
  //     }
  
  //     // Check audio permission
  //     const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //     if (permissionResult === RESULTS.GRANTED) {
  //       console.log('Audio permission granted');
  
  //       // Play the audio
  //       await audioRecorderPlayer.startPlayer(audioUri);
  //     } else {
  //       console.log('Audio permission not granted. Requesting permission...');
  //       const permissionRequestResult = await request(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //       if (permissionRequestResult === RESULTS.GRANTED) {
  //         console.log('Audio permission granted after request');
  
  //         // Play the audio
  //         await audioRecorderPlayer.startPlayer(audioUri);
  //       } else {
  //         console.log('Audio permission denied');
  //       }
  //     }
  //     setIsPlaying(!isPlaying); 
  //   } catch (error) {
  //     console.error('Error playing recording:', error);
  //   }
  // };
  

  // useEffect(() => {
  //   const audioRecorderPlayer = new AudioRecorderPlayer();
  //   // ... rest of your code ...
  //   return () => {
  //     audioRecorderPlayer.stopPlayer();
  //     audioRecorderPlayer.removeRecordBackListener();
  //     audioRecorderPlayer.removePlayBackListener();
  //   };
  // }, []);

          {audioUri ? (
          <View style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={playRecording}>
              <Ionicons
                name={isPlaying ? 'pause' : 'play'}
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
          </View>
        ) : null}

        
  // useEffect(() => {
  //   return () => {
  //     audioRecorderPlayer.stopPlayer();
  //     audioRecorderPlayer.removeRecordBackListener();
  //     audioRecorderPlayer.removePlayBackListener();
  //   };
  // }, []);







  import React, {useState, useEffect, useRef} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  ScrollView,
  Keyboard,
  Image,
  Modal,
  Dimensions,
  PermissionsAndroid,
  Share,
  Button,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';
import ImagePicker from 'react-native-image-crop-picker';
import ImagePreviewScreen from './ImagePreviewScreen';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import DocumentPicker from 'react-native-document-picker';
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import AudioRecorderPlayer from 'react-native-audio-recorder-player';
import RNFS from 'react-native-fs';
import { check, request, PERMISSIONS, RESULTS } from 'react-native-permissions';


const audioRecorderPlayer = new AudioRecorderPlayer();
const {height, width} = Dimensions.get('window');

const GlobalChatScreen = ({route, navigation}) => {
  const [inputText, setInputText] = useState('');
  const [messages, setMessages] = useState([]);
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  const [showImagePreview, setShowImagePreview] = useState(false);
  const [bottom, setBottom] = useState(false);
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [selectedDocuments, setSelectedDocuments] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [audioUri, setAudioUri] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const [audioMessages, setAudioMessages] = useState([]);

  useEffect(() => {
    const {image, text} = route.params || {};
    if (image || text) {
      const newMessage = {text, image: image || []};
      // const newMessage = {text, image: Array.isArray(image) ? image : [image]};
      setMessages([...messages, newMessage]);
    }
  }, [route.params]);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setIsKeyboardOpen(true);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setIsKeyboardOpen(false);
      },
    );
    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const sendMessage = () => {
    if (inputText || imageUrl || audioUri) {
      const newMessage = {
        text: inputText,
        image: imageUrl,
        audio: audioUri,
      };
      setMessages([...messages, newMessage]);
      setInputText('');
      setImageUrl('');
      setAudioUri('');
      // setImageUrl('');
      // && !imageUrl
    }
  };

  const usertextCamera = async () => {
    try {
      const image = await ImagePicker.openCamera({
        compressImageMaxWidth: 500,
        compressImageMaxHeight: 500,
        cropping: true,
        compressImageQuality: 0.7,
      });
      console.log(image);

      // Make sure to set imageUrl to the correct image path
      if (image && image.path) {
        setImageUrl(image.path);
        setShowImagePreview(true); // Assuming you want to show the preview immediately
        console.log('imageUrl:', imageUrl); // Log imageUrl here
      } else {
        console.warn('Image path is null or undefined.');
      }
    } catch (error) {
      console.error('Error picking image from camera:', error);
    }
  };

  const userGalleryOpen = () => {
    ImagePicker.openPicker({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      // cropping: true,
      multiple: true,
    }).then(images => {
      console.log(images);

      if (images && images.length > 0) {
        setImageUrl(images[0].path);
        setShowImagePreview(true);
      }
    });
  };

  const closeImagePreview = () => {
    setShowImagePreview(false);
  };

  const plusBotton = () => {
    setBottom(!bottom);
  };

  const Pluscancelbutton = async () => {
    setBottom(!bottom);
  };

  const pickDocument = async () => {
    try {
      const [result] = await DocumentPicker.pick({
        type: [DocumentPicker.types.allFiles],
      });

      console.log('Complete Document Result:', result);

      // Log specific properties to check their values
      console.log('Document Name:', result.name);
      console.log('Document Size (bytes):', result.size);
      console.log('Document URI:', result.uri);

      const newDocument = {
        name: result.name || 'Untitled',
        size: result.size || 0, // File size in bytes
        uri: result.uri || 'Unknown URI',
      };

      setSelectedDocuments([...selectedDocuments, newDocument]);
      console.log('Selected documents updated:', selectedDocuments);
    } catch (err) {
      if (DocumentPicker.isCancel(err)) {
        console.log('Document picking cancelled');
      } else {
        console.error('Error picking document:', err);
      }
    }
  };

  const formatFileSize = sizeInBytes => {
    if (sizeInBytes < 1024) {
      return Math.round(sizeInBytes) + ' B';
    } else if (sizeInBytes < 1024 * 1024) {
      return Math.round(sizeInBytes / 1024) + ' KB';
    } else if (sizeInBytes < 1024 * 1024 * 1024) {
      return Math.round(sizeInBytes / (1024 * 1024)) + ' MB';
    } else {
      return Math.round(sizeInBytes / (1024 * 1024 * 1024)) + ' GB';
    }
  };

  const openModal = document => {
    setSelectedDocument(document);
    setIsModalVisible(true);
  };

  const renderDocumentContent = () => {
    if (selectedDocument && selectedDocument.uri) {
      if (selectedDocument.type && selectedDocument.type.startsWith('image/')) {
        // Displaying an image
        return (
          <Image
            source={{uri: selectedDocument.uri}}
            style={styles.modalImage}
          />
        );
      } else {
        // Handling other types of documents
        return <View></View>;
      }
    } else {
      return <Text>No document content available</Text>;
    }
  };

  const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');
  
        // Start recording
        const result = await audioRecorderPlayer.startRecorder();
        setIsRecording(true);
        console.log(result);
      } else {
        console.log('Audio recording permission not granted. Requesting permission...');
        
        // Request audio recording permission
        const permissionRequestResult = await request(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');
  
          // Start recording
          const result = await audioRecorderPlayer.startRecorder();
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };
  
  const stopRecording = async () => {
    try {
      const result = await audioRecorderPlayer.stopRecorder();
      setIsRecording(false);
      setAudioUri(result);
      setAudioMessages([...audioMessages, result]);
      console.log(result);
    } catch (error) {
      console.error('Error stopping recording:', error);
    }
  };

  const playRecording = async () => {
    try {
      console.log('Audio URI:', audioUri);

      // Check if audioUri is available
      if (!audioUri) {
        console.error('Audio URI is empty or undefined.');
        return;
      }

      // Check audio permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);

      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio permission granted');

        // Play the audio
        await audioRecorderPlayer.startPlayer(audioUri);
      } else {
        console.log('Audio permission not granted. Requesting permission...');
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO
        );

        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio permission granted after request');

          // Play the audio
          await audioRecorderPlayer.startPlayer(audioUri);
        } else {
          console.log('Audio permission denied');
        }
      }
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Error playing recording:', error);
    }
  };

  useEffect(() => {
    return () => {
      audioRecorderPlayer.stopPlayer();
      audioRecorderPlayer.removeRecordBackListener();
      audioRecorderPlayer.removePlayBackListener();
    };
  }, []);

  return (
    <KeyboardAvoidingView behavior="padding" style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back-outline" size={30} color="black" />
        </TouchableOpacity>
        <TouchableOpacity>
          <Ionicons name="videocam-outline" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <TouchableOpacity
                  key={docIndex}
                  style={styles.documentContainer}
                  onPress={() => openModal(document)}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {formatFileSize(document.size)}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))}
            {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Image
                  key={imgIndex}
                  source={{uri: image}}
                  style={styles.image}
                  resizeMode="cover"
                />
              ))}
            {message.text && (
              <Text style={styles.messageText}>{message.text}</Text>
            )}
          </View>
        ))}
        {audioMessages.map((audioUri, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(audioUri)}>
              <Ionicons
                name={isPlaying ? 'pause' : 'play'}
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <TouchableOpacity
            key={index}
            style={styles.messageContainer}
            onPress={() => openModal(document)}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName} numberOfLines={1}>
                  {document.name.length > 20
                    ? document.name.substring(0, 15) + '...'
                    : document.name}
                </Text>
                <Text style={styles.documentSize}>
                  {formatFileSize(document.size)}
                </Text>
              </View>
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
      <Modal
        visible={isModalVisible}
        onRequestClose={() => setIsModalVisible(false)}
        transparent={true}>
        <TouchableOpacity
          style={styles.modalContainer}
          onPress={() => setIsModalVisible(false)}>
          {renderDocumentContent()}
        </TouchableOpacity>
      </Modal>
      {bottom && (
        <>
          <View style={styles.bottomboxone}>
            <TouchableOpacity
              style={styles.camerplusicon}
              onPress={usertextCamera}>
              <Ionicons
                name="camera"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Camera
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Gallery
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={pickDocument}>
              <Ionicons
                name="document-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Document
              </Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.Accountplusicon}>
              <MaterialCommunityIcons
                name="account-circle"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Tag Person
              </Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity
            style={styles.bottomboxtwo}
            onPress={Pluscancelbutton}>
            <Text style={styles.canceltext}>Cancel</Text>
          </TouchableOpacity>
        </>
      )}
      <View style={styles.inputContainer}>
        {!isKeyboardOpen && (
          <TouchableOpacity style={styles.cameraicon} onPress={usertextCamera}>
            <Ionicons name="camera" size={25} color="black" />
          </TouchableOpacity>
        )}
        <TextInput
          style={styles.textInput}
          placeholder="Type your message..."
          value={inputText}
          onChangeText={setInputText}
        />
        {isKeyboardOpen ? (
          <View style={{flexDirection: 'row'}}>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo
                name="plus"
                size={25}
                color="black"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={sendMessage}
              style={styles.sendiconbutton}
              disabled={inputText.trim().length === 0}>
              <Entypo name="paper-plane" size={30} color="black" />
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo name="plus" size={25} color="black" style={styles.icon} />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={isRecording ? stopRecording : startRecording}>
              <Ionicons
                name={isRecording ? 'stop' : 'mic-outline'}
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
            <TouchableOpacity onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
          </>
        )}
      </View>
      <Modal
        visible={showImagePreview}
        transparent={false}
        animationType="slide"
        onRequestClose={closeImagePreview}>
        <ImagePreviewScreen
          imageUrl={imageUrl}
          onClose={closeImagePreview}
          // onSendMessage={setInputText}
          navigation={navigation}
          // setImageUrl={setImageUrl}
        />
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  contentContainer: {
    flexGrow: 1,
    backgroundColor: 'white',
  },
  messageContainer: {
    padding: 8,
    marginVertical: 4,
    borderTopLeftRadius: 15,
    borderBottomLeftRadius: 15,
    borderTopRightRadius: 10,
    borderBottomRightRadius: 0,
    backgroundColor: '#DCF8c5',
    maxWidth: '80%',
    alignSelf: 'flex-end',
    marginRight: 10,
    flexDirection: 'column',
  },
  image: {
    width: 300,
    height: 300,
    borderRadius: 8,
    marginTop: 8,
  },
  messageText: {
    fontSize: 16,
    color: 'black',
  },
  micplayicon:{
    color: 'gray',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'lightgray',
    padding: 10,
    backgroundColor: 'whitesmoke',
  },
  textInput: {
    height: 40,
    borderWidth: 1,
    width: '60%',
    borderColor: 'grey',
    borderRadius: 20,
    padding: 8,
    marginHorizontal: 5,
    // backgroundColor:"silver",
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  sendiconbutton: {
    padding: 10,
    marginLeft: 15,
  },
  icon: {
    marginHorizontal: 5,
  },
  iconss: {
    padding: 10,
  },
  plusIcon: {
    marginRight: 15,
  },
  bottomboxone: {
    width: '90%',
    height: 300,
    borderRadius: 20,
    backgroundColor: '#BFBFBF',
    position: 'absolute',
    bottom: 150,
    left: '5%',
    right: '5%',
  },
  bottomboxtwo: {
    width: '90%',
    height: 60,
    borderRadius: 20,
    position: 'absolute',
    bottom: 80,
    left: '5%',
    right: '5%',
    backgroundColor: '#BFBFBF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  canceltext: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'black',
  },
  camerplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 20,
    borderBottomLeftRadius: 0,
    borderTopRightRadius: 20,
    borderBottomRightRadius: 0,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  imageplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  Accountplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 20,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 20,
  },
  documentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#BFBFBF',
    padding: 10,
    borderRadius: 8,
    marginLeft: 8,
  },
  documentInfo: {
    marginLeft: 8,
  },
  documentName: {
    fontSize: 16,
    color: 'black',
  },
  documentSize: {
    fontSize: 12,
    color: 'black',
  },
  audioPlaybackContainer:{
    backgroundColor: '#DCF8c5', 
    borderRadius: 8,
    padding: 10,
    marginRight: 8,
    alignSelf: 'flex-end',
  },
});

export default GlobalChatScreen;

import React, {useState, useEffect, useRef} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  ScrollView,
  Keyboard,
  Image,
  Modal,
  Dimensions,
  PermissionsAndroid,
  Share,
  Button,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';
import ImagePicker from 'react-native-image-crop-picker';
import ImagePreviewScreen from './ImagePreviewScreen';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import DocumentPicker from 'react-native-document-picker';
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import AudioRecorderPlayer from 'react-native-audio-recorder-player';
import RNFS from 'react-native-fs';
import { check, request, PERMISSIONS, RESULTS } from 'react-native-permissions';


const audioRecorderPlayer = new AudioRecorderPlayer();
const {height, width} = Dimensions.get('window');

const GlobalChatScreen = ({route, navigation}) => {
  const [inputText, setInputText] = useState('');
  const [messages, setMessages] = useState([]);
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  const [showImagePreview, setShowImagePreview] = useState(false);
  const [bottom, setBottom] = useState(false);
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [selectedDocuments, setSelectedDocuments] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [audioUri, setAudioUri] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const [audioMessages, setAudioMessages] = useState([]);
  const [currentAudioIndex, setCurrentAudioIndex] = useState(null);

  useEffect(() => {
    const {image, text} = route.params || {};
    if (image || text) {
      const newMessage = {text, image: image || []};
      // const newMessage = {text, image: Array.isArray(image) ? image : [image]};
      setMessages([...messages, newMessage]);
    }
  }, [route.params]);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setIsKeyboardOpen(true);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setIsKeyboardOpen(false);
      },
    );
    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const sendMessage = () => {
    if (inputText || imageUrl || audioUri) {
      const newMessage = {
        text: inputText,
        image: imageUrl,
        audio: audioUri,
      };
      setMessages([...messages, newMessage]);
      setInputText('');
      setImageUrl('');
      setAudioUri('');
      // setImageUrl('');
      // && !imageUrl
    }
  };

  const usertextCamera = async () => {
    try {
      const image = await ImagePicker.openCamera({
        compressImageMaxWidth: 500,
        compressImageMaxHeight: 500,
        cropping: true,
        compressImageQuality: 0.7,
      });
      console.log(image);

      // Make sure to set imageUrl to the correct image path
      if (image && image.path) {
        setImageUrl(image.path);
        setShowImagePreview(true); // Assuming you want to show the preview immediately
        console.log('imageUrl:', imageUrl); // Log imageUrl here
      } else {
        console.warn('Image path is null or undefined.');
      }
    } catch (error) {
      console.error('Error picking image from camera:', error);
    }
  };

  const userGalleryOpen = () => {
    ImagePicker.openPicker({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      // cropping: true,
      multiple: true,
    }).then(images => {
      console.log(images);

      if (images && images.length > 0) {
        setImageUrl(images[0].path);
        setShowImagePreview(true);
      }
    });
  };

  const closeImagePreview = () => {
    setShowImagePreview(false);
  };

  const plusBotton = () => {
    setBottom(!bottom);
  };

  const Pluscancelbutton = async () => {
    setBottom(!bottom);
  };

  const pickDocument = async () => {
    try {
      const [result] = await DocumentPicker.pick({
        type: [DocumentPicker.types.allFiles],
      });

      console.log('Complete Document Result:', result);

      // Log specific properties to check their values
      console.log('Document Name:', result.name);
      console.log('Document Size (bytes):', result.size);
      console.log('Document URI:', result.uri);

      const newDocument = {
        name: result.name || 'Untitled',
        size: result.size || 0, // File size in bytes
        uri: result.uri || 'Unknown URI',
      };

      setSelectedDocuments([...selectedDocuments, newDocument]);
      console.log('Selected documents updated:', selectedDocuments);
    } catch (err) {
      if (DocumentPicker.isCancel(err)) {
        console.log('Document picking cancelled');
      } else {
        console.error('Error picking document:', err);
      }
    }
  };

  const formatFileSize = sizeInBytes => {
    if (sizeInBytes < 1024) {
      return Math.round(sizeInBytes) + ' B';
    } else if (sizeInBytes < 1024 * 1024) {
      return Math.round(sizeInBytes / 1024) + ' KB';
    } else if (sizeInBytes < 1024 * 1024 * 1024) {
      return Math.round(sizeInBytes / (1024 * 1024)) + ' MB';
    } else {
      return Math.round(sizeInBytes / (1024 * 1024 * 1024)) + ' GB';
    }
  };

  const openModal = document => {
    setSelectedDocument(document);
    setIsModalVisible(true);
  };

  const renderDocumentContent = () => {
    if (selectedDocument && selectedDocument.uri) {
      if (selectedDocument.type && selectedDocument.type.startsWith('image/')) {
        // Displaying an image
        return (
          <Image
            source={{uri: selectedDocument.uri}}
            style={styles.modalImage}
          />
        );
      } else {
        // Handling other types of documents
        return <View></View>;
      }
    } else {
      return <Text>No document content available</Text>;
    }
  };

  const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');
  
        // Start recording
        const result = await audioRecorderPlayer.startRecorder();
        setIsRecording(true);
        console.log(result);
      } else {
        console.log('Audio recording permission not granted. Requesting permission...');
        
        // Request audio recording permission
        const permissionRequestResult = await request(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');
  
          // Start recording
          const result = await audioRecorderPlayer.startRecorder();
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };
  
  const stopRecording = async () => {
    try {
      const result = await audioRecorderPlayer.stopRecorder();
      setIsRecording(false);
      setAudioUri(result);
      setAudioMessages([...audioMessages, result]);
      console.log(result);
    } catch (error) {
      console.error('Error stopping recording:', error);
    }
  };

  const playRecording = async (index) => {
    try {
      console.log('Audio URI:', audioUri);
  
      // Check if audioUri is available
      if (!audioUri) {
        console.error('Audio URI is empty or undefined.');
        return;
      }
  
      // Check audio permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio permission granted');
  
        // Play the audio
        await audioRecorderPlayer.startPlayer(audioUri);
  
        // Update the currentAudioIndex and isPlaying state
        setCurrentAudioIndex(index);
        setIsPlaying(!isPlaying);
      } else {
        console.log('Audio permission not granted. Requesting permission...');
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO
        );
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio permission granted after request');
  
          // Play the audio
          await audioRecorderPlayer.startPlayer(audioUri);
  
          // Update the currentAudioIndex and isPlaying state
          setCurrentAudioIndex(index);
          setIsPlaying(!isPlaying);
        } else {
          console.log('Audio permission denied');
        }
      }
    } catch (error) {
      console.error('Error playing recording:', error);
    }
  };
  

  useEffect(() => {
    return () => {
      audioRecorderPlayer.stopPlayer();
      audioRecorderPlayer.removeRecordBackListener();
      audioRecorderPlayer.removePlayBackListener();
    };
  }, []);

  return (
    <KeyboardAvoidingView behavior="padding" style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back-outline" size={30} color="black" />
        </TouchableOpacity>
        <TouchableOpacity>
          <Ionicons name="videocam-outline" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <TouchableOpacity
                  key={docIndex}
                  style={styles.documentContainer}
                  onPress={() => openModal(document)}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {formatFileSize(document.size)}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))}
            {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Image
                  key={imgIndex}
                  source={{uri: image}}
                  style={styles.image}
                  resizeMode="cover"
                />
              ))}
            {message.text && (
              <Text style={styles.messageText}>{message.text}</Text>
            )}
          </View>
        ))}
        {audioMessages.map((audioUri, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <TouchableOpacity
            key={index}
            style={styles.messageContainer}
            onPress={() => openModal(document)}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName} numberOfLines={1}>
                  {document.name.length > 20
                    ? document.name.substring(0, 15) + '...'
                    : document.name}
                </Text>
                <Text style={styles.documentSize}>
                  {formatFileSize(document.size)}
                </Text>
              </View>
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
      <Modal
        visible={isModalVisible}
        onRequestClose={() => setIsModalVisible(false)}
        transparent={true}>
        <TouchableOpacity
          style={styles.modalContainer}
          onPress={() => setIsModalVisible(false)}>
          {renderDocumentContent()}
        </TouchableOpacity>
      </Modal>
      {bottom && (
        <>
          <View style={styles.bottomboxone}>
            <TouchableOpacity
              style={styles.camerplusicon}
              onPress={usertextCamera}>
              <Ionicons
                name="camera"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Camera
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Gallery
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={pickDocument}>
              <Ionicons
                name="document-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Document
              </Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.Accountplusicon}>
              <MaterialCommunityIcons
                name="account-circle"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Tag Person
              </Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity
            style={styles.bottomboxtwo}
            onPress={Pluscancelbutton}>
            <Text style={styles.canceltext}>Cancel</Text>
          </TouchableOpacity>
        </>
      )}
      <View style={styles.inputContainer}>
        {!isKeyboardOpen && (
          <TouchableOpacity style={styles.cameraicon} onPress={usertextCamera}>
            <Ionicons name="camera" size={25} color="black" />
          </TouchableOpacity>
        )}
        <TextInput
          style={styles.textInput}
          placeholder="Type your message..."
          value={inputText}
          onChangeText={setInputText}
        />
        {isKeyboardOpen ? (
          <View style={{flexDirection: 'row'}}>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo
                name="plus"
                size={25}
                color="black"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={sendMessage}
              style={styles.sendiconbutton}
              disabled={inputText.trim().length === 0}>
              <Entypo name="paper-plane" size={30} color="black" />
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo name="plus" size={25} color="black" style={styles.icon} />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={isRecording ? stopRecording : startRecording}>
              <Ionicons
                name={isRecording ? 'stop' : 'mic-outline'}
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
            <TouchableOpacity onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
          </>
        )}
      </View>
      <Modal
        visible={showImagePreview}
        transparent={false}
        animationType="slide"
        onRequestClose={closeImagePreview}>
        <ImagePreviewScreen
          imageUrl={imageUrl}
          onClose={closeImagePreview}
          // onSendMessage={setInputText}
          navigation={navigation}
          // setImageUrl={setImageUrl}
        />
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  contentContainer: {
    flexGrow: 1,
    backgroundColor: 'white',
  },
  messageContainer: {
    padding: 8,
    marginVertical: 4,
    borderTopLeftRadius: 15,
    borderBottomLeftRadius: 15,
    borderTopRightRadius: 10,
    borderBottomRightRadius: 0,
    backgroundColor: '#DCF8c5',
    maxWidth: '80%',
    alignSelf: 'flex-end',
    marginRight: 10,
    flexDirection: 'column',
  },
  image: {
    width: 300,
    height: 300,
    borderRadius: 8,
    marginTop: 8,
  },
  messageText: {
    fontSize: 16,
    color: 'black',
  },
  micplayicon:{
    color: 'gray',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'lightgray',
    padding: 10,
    backgroundColor: 'whitesmoke',
  },
  textInput: {
    height: 40,
    borderWidth: 1,
    width: '60%',
    borderColor: 'grey',
    borderRadius: 20,
    padding: 8,
    marginHorizontal: 5,
    // backgroundColor:"silver",
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  sendiconbutton: {
    padding: 10,
    marginLeft: 15,
  },
  icon: {
    marginHorizontal: 5,
  },
  iconss: {
    padding: 10,
  },
  plusIcon: {
    marginRight: 15,
  },
  bottomboxone: {
    width: '90%',
    height: 300,
    borderRadius: 20,
    backgroundColor: '#BFBFBF',
    position: 'absolute',
    bottom: 150,
    left: '5%',
    right: '5%',
  },
  bottomboxtwo: {
    width: '90%',
    height: 60,
    borderRadius: 20,
    position: 'absolute',
    bottom: 80,
    left: '5%',
    right: '5%',
    backgroundColor: '#BFBFBF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  canceltext: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'black',
  },
  camerplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 20,
    borderBottomLeftRadius: 0,
    borderTopRightRadius: 20,
    borderBottomRightRadius: 0,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  imageplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  Accountplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 20,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 20,
  },
  documentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#BFBFBF',
    padding: 10,
    borderRadius: 8,
    marginLeft: 8,
  },
  documentInfo: {
    marginLeft: 8,
  },
  documentName: {
    fontSize: 16,
    color: 'black',
  },
  documentSize: {
    fontSize: 12,
    color: 'black',
  },
  audioPlaybackContainer:{
    backgroundColor: '#DCF8c5', 
    borderRadius: 8,
    padding: 10,
    marginRight: 8,
    alignSelf: 'flex-end',
  },
});

export default GlobalChatScreen;

  // const playRecording = async (index) => {
  //   try {
  //     console.log('Audio URI:', audioUri);
  
  //     // Check if audioUri is available
  //     if (!audioUri) {
  //       console.error('Audio URI is empty or undefined.');
  //       return;
  //     }
  
  //     // Check audio permission
  //     const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //     if (permissionResult === RESULTS.GRANTED) {
  //       console.log('Audio permission granted');
  
  //       // Play the audio
  //       await audioRecorderPlayer.startPlayer(audioUri);
  
  //       // Update the currentAudioIndex and isPlaying state
  //       setCurrentAudioIndex(index);
  //       setIsPlaying(!isPlaying);
  //     } else {
  //       console.log('Audio permission not granted. Requesting permission...');
  //       const permissionRequestResult = await request(
  //         PERMISSIONS.ANDROID.RECORD_AUDIO
  //       );
  
  //       if (permissionRequestResult === RESULTS.GRANTED) {
  //         console.log('Audio permission granted after request');
  
  //         // Play the audio
  //         await audioRecorderPlayer.startPlayer(audioUri);
  
  //         // Update the currentAudioIndex and isPlaying state
  //         setCurrentAudioIndex(index);
  //         setIsPlaying(!isPlaying);
  //       } else {
  //         console.log('Audio permission denied');
  //       }
  //     }
  //   } catch (error) {
  //     console.error('Error playing recording:', error);
  //   }
  // };
  
  // const playRecording = async (index) => {
  //   try {
  //     // Check if audioUri is available
  //     if (!audioMessages[index]) {
  //       console.error('Audio URI is empty or undefined.');
  //       return;
  //     }
  
  //     // Check audio permission
  //     const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //     if (permissionResult === RESULTS.GRANTED) {
  //       console.log('Audio permission granted');
  
  //       // Play the audio
  //       const result = await audioRecorderPlayer.startPlayer(audioMessages[index]);
        
  //       // Update the currentAudioIndex and isPlaying state
  //       setCurrentAudioIndex(index);
  //       setIsPlaying(!isPlaying);
  //     } else {
  //       console.log('Audio permission not granted. Requesting permission...');
  //       const permissionRequestResult = await request(
  //         PERMISSIONS.ANDROID.RECORD_AUDIO
  //       );
  
  //       if (permissionRequestResult === RESULTS.GRANTED) {
  //         console.log('Audio permission granted after request');
  
  //         // Play the audio
  //         const result = await audioRecorderPlayer.startPlayer(audioMessages[index]);
          
  //         // Update the currentAudioIndex and isPlaying state
  //         setCurrentAudioIndex(index);
  //         setIsPlaying(!isPlaying);
  //       } else {
  //         console.log('Audio permission denied');
  //       }
  //     }
  //   } catch (error) {
  //     console.error('Error playing recording:', error);
  //   }
  // };

          {/* {audioMessages.map((audioUri, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
          </View>
        ))} */}
        {/* {audioMessages.map((audioUri, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
            {index === currentAudioIndex && isPlaying && (
              <View style={styles.audioProgressContainer}>
                <Text style={styles.audioProgressText}>
                  {audioRecorderPlayer.mmssss(
                    Math.floor(audioRecorderPlayer.currentPosition),
                  )}
                </Text>
                <Slider
                  style={styles.audioSlider}
                  value={audioRecorderPlayer.currentPosition}
                  maximumValue={audioRecorderPlayer.duration}
                  minimumValue={0}
                  minimumTrackTintColor="#DCF8c5"
                  maximumTrackTintColor="#BFBFBF"
                  thumbTintColor="#BFBFBF"
                />
                <Text style={styles.audioProgressText}>
                  {audioRecorderPlayer.mmssss(
                    Math.floor(audioRecorderPlayer.duration),
                  )}
                </Text>
              </View>
            )}
          </View>
        ))} */}
        {/* {audioRecordings.map((audio, index) => (
        <View key={index} style={styles.audioPlaybackContainer}>
          <TouchableOpacity onPress={() => playRecording(index)}>
            <Ionicons
              name={index === currentAudioIndex && isPlaying ? 'pause' : 'play'}
              size={30}
              color="#BFBFBF"
              style={styles.micplayicon}
            />
          </TouchableOpacity>
          {index === currentAudioIndex && isPlaying && (
            <View style={styles.audioProgressContainer}>
              <Text style={styles.audioProgressText}>
                {audio.duration}
              </Text>
              <Slider
                style={styles.audioSlider}
                value={audioRecorderPlayer.currentPosition}
                maximumValue={audioRecorderPlayer.duration}
                minimumValue={0}
                minimumTrackTintColor="#DCF8c5"
                maximumTrackTintColor="#BFBFBF"
                thumbTintColor="#BFBFBF"
              />
              <Text style={styles.audioProgressText}>
                {audio.duration}
              </Text>
            </View>
          )}
        </View>
      ))} */}


       // const startRecording = async () => {
  //   try {
  //     // Check audio recording permission
  //     const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //     if (permissionResult === RESULTS.GRANTED) {
  //       console.log('Audio recording permission granted');
  
  //       // Start recording
  //       const result = await audioRecorderPlayer.startRecorder();
  //       setIsRecording(true);
  //       console.log(result);
  //     } else {
  //       console.log('Audio recording permission not granted. Requesting permission...');
        
  //       // Request audio recording permission
  //       const permissionRequestResult = await request(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //       if (permissionRequestResult === RESULTS.GRANTED) {
  //         console.log('Audio recording permission granted after request');
  
  //         // Start recording
  //         const result = await audioRecorderPlayer.startRecorder();
  //         setIsRecording(true);
  //         console.log(result);
  //       } else {
  //         console.log('Audio recording permission denied');
  //       }
  //     }
  //   } catch (error) {
  //     console.error('Error starting recording:', error);
  //   }
  // };
  
  // const stopRecording = async () => {
  //   try {
  //     const result = await audioRecorderPlayer.stopRecorder();
  //     setIsRecording(false);
  //     setAudioUri(result);
  //     setAudioMessages([...audioMessages, result]);
  //     console.log(result);
  //   } catch (error) {
  //     console.error('Error stopping recording:', error);
  //   }
  // };

  // const stopRecording = async () => {
  //   try {
  //     const result = await audioRecorderPlayer.stopRecorder();
  //     setIsRecording(false);
  //     const duration = audioRecorderPlayer.duration;
  //     const formattedDuration = audioRecorderPlayer.mmssss(Math.floor(duration));
  //     setAudioRecordings([...audioRecordings, { uri: result, duration: formattedDuration }]);
  //     console.log(result);
  //   } catch (error) {
  //     console.error('Error stopping recording:', error);
  //   }
  // };
  

  // const playRecording = async (index) => {
  //   try {
  //     // Check if audioUri is available
  //     const audioUri = audioMessages[index];
  //     if (!audioUri) {
  //       console.error('Audio URI is empty or undefined.');
  //       return;
  //     }
  
  //     // Check audio permission
  //     const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
  //     if (permissionResult === RESULTS.GRANTED) {
  //       console.log('Audio permission granted');
  
  //       // Play the audio
  //       const result = await audioRecorderPlayer.startPlayer(audioUri);
  
  //       // Update the currentAudioIndex and isPlaying state
  //       setCurrentAudioIndex(index);
  //       setIsPlaying(!isPlaying);
  //     } else {
  //       console.log('Audio permission not granted. Requesting permission...');
  //       const permissionRequestResult = await request(
  //         PERMISSIONS.ANDROID.RECORD_AUDIO
  //       );
  
  //       if (permissionRequestResult === RESULTS.GRANTED) {
  //         console.log('Audio permission granted after request');
  
  //         // Play the audio
  //         const result = await audioRecorderPlayer.startPlayer(audioUri);
  
  //         // Update the currentAudioIndex and isPlaying state
  //         setCurrentAudioIndex(index);
  //         setIsPlaying(!isPlaying);
  //       } else {
  //         console.log('Audio permission denied');
  //       }
  //     }
  //   } catch (error) {
  //     console.error('Error playing recording:', error);
  //   }
  // };

  const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');
  
        // Start recording
        const result = await audioRecorderPlayer.startRecorder();
        setIsRecording(true);
        console.log(result);
      } else {
        console.log('Audio recording permission not granted. Requesting permission...');
  
        // Request audio recording permission
        const permissionRequestResult = await request(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');
  
          // Start recording
          const result = await audioRecorderPlayer.startRecorder();
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };
  
  // const stopRecording = async () => {
  //   try {
  //     const result = await audioRecorderPlayer.stopRecorder();
  //     setIsRecording(false);
  
  //     // Calculate duration using start and stop timestamps
  //     const startTimestamp = audioRecorderPlayer.currentTimestamp;
  //     const stopTimestamp = new Date().getTime();
  //     const durationInSeconds = Math.floor((stopTimestamp - startTimestamp) / 1000);
  //     const formattedDuration = audioRecorderPlayer.mmssss(durationInSeconds);
  
  //     const newRecording = { uri: result, duration: formattedDuration };
      
  //     setAudioRecordings([...audioRecordings, newRecording]);
  //     setAudioMessages([...audioMessages, newRecording]);
  
  //     console.log(result);
  //   } catch (error) {
  //     console.error('Error stopping recording:', error);
  //   }
  // };

        {/* {audioRecordings.map((audio, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
            {index === currentAudioIndex && isPlaying && (
              <View style={styles.audioProgressContainer}>
                <Text style={styles.audioProgressText}>
                  {audioRecorderPlayer.mmssss(
                    Math.floor(audioRecorderPlayer.currentPosition),
                  )}
                </Text>
                <Slider
                  style={styles.audioSlider}
                  value={audioRecorderPlayer.currentPosition}
                  maximumValue={audioRecorderPlayer.duration}
                  minimumValue={0}
                  minimumTrackTintColor="#DCF8c5"
                  maximumTrackTintColor="#BFBFBF"
                  thumbTintColor="#BFBFBF"
                />
                <Text style={styles.audioProgressText}>
                  {audioRecorderPlayer.mmssss(
                    Math.floor(audioRecorderPlayer.duration),
                  )}
                </Text>
              </View>
            )}
            <Text style={styles.audioDurationText}>
              {formatDuration(Math.round(audio.stop - audio.start))}
            </Text>
          </View>
        ))} */}

          const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');
  
        // Start recording with MP3 format
        const result = await audioRecorderPlayer.startRecorder();
  
        setIsRecording(true);
        console.log(result);
      } else {
        console.log(
          'Audio recording permission not granted. Requesting permission...',
        );
  
        // Request audio recording permission
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');
  
          // Start recording with MP3 format
          const result = await audioRecorderPlayer.startRecorder({
            format: 'mp3', // Specify the output file format
          });
  
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };
  
  
  const stopRecording = async () => {
    try {
      const result = await audioRecorderPlayer.stopRecorder();
      setIsRecording(false);
  
      // Calculate duration using start and stop timestamps
      const startTimestamp = audioRecorderPlayer.currentTimestamp;
      const stopTimestamp = new Date().getTime();
      const durationInSeconds = Math.round(
        (stopTimestamp - startTimestamp) / 1000,
      ); // Round to the nearest second
      const formattedDuration = audioRecorderPlayer.mmssss(
        durationInSeconds,
      );
  
      const newRecording = {
        uri: result,
        duration: formattedDuration,
        start: startTimestamp,
        stop: stopTimestamp,
      };
  
      setAudioRecordings([...audioRecordings, newRecording]);
      setAudioMessages([...audioMessages, newRecording]);
  
      console.log(result);
    } catch (error) {
      console.error('Error stopping recording:', error);
    }
  };
  
  const playRecording = async index => {
    try {
      // Check if audioUri is available
      const audioMessage = audioMessages[index];
      if (!audioMessage || !audioMessage.uri) {
        console.error('Audio message or URI is empty or undefined.');
        return;
      }
  
      // Check audio permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
  
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio permission granted');
  
        // Play the audio
        const result = await audioRecorderPlayer.startPlayer(audioMessage.uri);
  
        // Update the currentAudioIndex and isPlaying state
        setCurrentAudioIndex(index);
        setIsPlaying(!isPlaying);
      } else {
        console.log('Audio permission not granted. Requesting permission...');
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );
  
        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio permission granted after request');
  
          // Play the audio
          const result = await audioRecorderPlayer.startPlayer(
            audioMessage.uri,
          );
  
          // Update the currentAudioIndex and isPlaying state
          setCurrentAudioIndex(index);
          setIsPlaying(!isPlaying);
        } else {
          console.log('Audio permission denied');
        }
      }
    } catch (error) {
      console.error('Error playing recording:', error);
    }
  };

    const formatDuration = milliseconds => {
    if (isNaN(milliseconds) || milliseconds < 0) {
      return '0 seconds';
    }

    const seconds = Math.round(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;

    if (minutes === 0) {
      return `${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`;
    }

    if (remainingSeconds === 0) {
      return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
    }

    return `${minutes} minute${
      minutes !== 1 ? 's' : ''
    } ${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`;
  };

  import React, {useState, useEffect, useRef} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  ScrollView,
  Keyboard,
  Image,
  Modal,
  Dimensions,
  PermissionsAndroid,
  Share,
  Button,
  Platform,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';
import ImagePicker from 'react-native-image-crop-picker';
import ImagePreviewScreen from './ImagePreviewScreen';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import DocumentPicker from 'react-native-document-picker';
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import AudioRecorderPlayer from 'react-native-audio-recorder-player';
import {check, request, PERMISSIONS, RESULTS} from 'react-native-permissions';
import Slider from '@react-native-community/slider';
import RNFS from 'react-native-fs';


const audioRecorderPlayer = new AudioRecorderPlayer();
const {height, width} = Dimensions.get('window');

const GlobalChatScreen = ({route, navigation}) => {
  const [inputText, setInputText] = useState('');
  const [messages, setMessages] = useState([]);
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  const [showImagePreview, setShowImagePreview] = useState(false);
  const [bottom, setBottom] = useState(false);
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [selectedDocuments, setSelectedDocuments] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [audioUri, setAudioUri] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const [audioMessages, setAudioMessages] = useState([]);
  const [currentAudioIndex, setCurrentAudioIndex] = useState(null);
  const [audioRecordings, setAudioRecordings] = useState([]);

  useEffect(() => {
    const {image, text} = route.params || {};
    if (image || text) {
      const newMessage = {text, image: image || []};
      // const newMessage = {text, image: Array.isArray(image) ? image : [image]};
      setMessages([...messages, newMessage]);
    }
  }, [route.params]);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setIsKeyboardOpen(true);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setIsKeyboardOpen(false);
      },
    );
    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const sendMessage = () => {
    if (inputText || imageUrl || audioUri) {
      const newMessage = {
        text: inputText,
        image: imageUrl,
        audio: audioUri,
      };
      setMessages([...messages, newMessage]);
      setInputText('');
      setImageUrl('');
      setAudioUri('');
    }
  };

  const usertextCamera = async () => {
    try {
      const image = await ImagePicker.openCamera({
        compressImageMaxWidth: 500,
        compressImageMaxHeight: 500,
        cropping: true,
        compressImageQuality: 0.7,
      });
      console.log(image);

      // Make sure to set imageUrl to the correct image path
      if (image && image.path) {
        setImageUrl(image.path);
        setShowImagePreview(true); // Assuming you want to show the preview immediately
        console.log('imageUrl:', imageUrl); // Log imageUrl here
      } else {
        console.warn('Image path is null or undefined.');
      }
    } catch (error) {
      console.error('Error picking image from camera:', error);
    }
  };

  const userGalleryOpen = () => {
    ImagePicker.openPicker({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      // cropping: true,
      multiple: true,
    }).then(images => {
      console.log(images);

      if (images && images.length > 0) {
        setImageUrl(images[0].path);
        setShowImagePreview(true);
      }
    });
  };

  const closeImagePreview = () => {
    setShowImagePreview(false);
  };

  const plusBotton = () => {
    setBottom(!bottom);
  };

  const Pluscancelbutton = async () => {
    setBottom(!bottom);
  };

  const pickDocument = async () => {
    try {
      const [result] = await DocumentPicker.pick({
        type: [DocumentPicker.types.allFiles],
      });

      console.log('Complete Document Result:', result);

      // Log specific properties to check their values
      console.log('Document Name:', result.name);
      console.log('Document Size (bytes):', result.size);
      console.log('Document URI:', result.uri);

      const newDocument = {
        name: result.name || 'Untitled',
        size: result.size || 0, // File size in bytes
        uri: result.uri || 'Unknown URI',
      };

      setSelectedDocuments([...selectedDocuments, newDocument]);
      console.log('Selected documents updated:', selectedDocuments);
    } catch (err) {
      if (DocumentPicker.isCancel(err)) {
        console.log('Document picking cancelled');
      } else {
        console.error('Error picking document:', err);
      }
    }
  };

  const formatFileSize = sizeInBytes => {
    if (sizeInBytes < 1024) {
      return Math.round(sizeInBytes) + ' B';
    } else if (sizeInBytes < 1024 * 1024) {
      return Math.round(sizeInBytes / 1024) + ' KB';
    } else if (sizeInBytes < 1024 * 1024 * 1024) {
      return Math.round(sizeInBytes / (1024 * 1024)) + ' MB';
    } else {
      return Math.round(sizeInBytes / (1024 * 1024 * 1024)) + ' GB';
    }
  };

  const openModal = document => {
    setSelectedDocument(document);
    setIsModalVisible(true);
  };

  const renderDocumentContent = () => {
    if (selectedDocument && selectedDocument.uri) {
      if (selectedDocument.type && selectedDocument.type.startsWith('image/')) {
        // Displaying an image
        return (
          <Image
            source={{uri: selectedDocument.uri}}
            style={styles.modalImage}
          />
        );
      } else {
        // Handling other types of documents
        return <View></View>;
      }
    } else {
      return <Text>No document content available</Text>;
    }
  };

  const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);

      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');

        // Start recording
        const result = await audioRecorderPlayer.startRecorder();
        setIsRecording(true);
        console.log(result);
      } else {
        console.log(
          'Audio recording permission not granted. Requesting permission...',
        );

        // Request audio recording permission
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );

        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');

          // Start recording
          const result = await audioRecorderPlayer.startRecorder();
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };
  

  const stopRecording = async () => {
    try {
      const result = await audioRecorderPlayer.stopRecorder();
      setIsRecording(false);

      // Calculate duration using start and stop timestamps
      const startTimestamp = audioRecorderPlayer.currentTimestamp;
      const stopTimestamp = new Date().getTime();
      const durationInSeconds = Math.round(
        (stopTimestamp - startTimestamp) / 1000,
      ); // Round to nearest second
      const formattedDuration = audioRecorderPlayer.mmssss(durationInSeconds);

      const newRecording = {
        uri: result,
        duration: formattedDuration,
        start: startTimestamp,
        stop: stopTimestamp,
      };

      setAudioRecordings([...audioRecordings, newRecording]);
      setAudioMessages([...audioMessages, newRecording]);

      console.log(result);
    } catch (error) {
      console.error('Error stopping recording:', error);
    }
  };

  const playRecording = async index => {
    try {
      // Check if audioUri is available
      const audioMessage = audioMessages[index];
      if (!audioMessage || !audioMessage.uri) {
        console.error('Audio message or URI is empty or undefined.');
        return;
      }

      // Check audio permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);

      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio permission granted');

        // Play the audio
        const result = await audioRecorderPlayer.startPlayer(audioMessage.uri);

        // Update the currentAudioIndex and isPlaying state
        setCurrentAudioIndex(index);
        setIsPlaying(!isPlaying);
      } else {
        console.log('Audio permission not granted. Requesting permission...');
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );

        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio permission granted after request');

          // Play the audio
          const result = await audioRecorderPlayer.startPlayer(
            audioMessage.uri,
          );

          // Update the currentAudioIndex and isPlaying state
          setCurrentAudioIndex(index);
          setIsPlaying(!isPlaying);
        } else {
          console.log('Audio permission denied');
        }
      }
    } catch (error) {
      console.error('Error playing recording:', error);
    }
  };

  useEffect(() => {
    return () => {
      audioRecorderPlayer.stopPlayer();
      audioRecorderPlayer.removeRecordBackListener();
      audioRecorderPlayer.removePlayBackListener();
    };
  }, []);

  const formatDuration = milliseconds => {
    if (isNaN(milliseconds) || milliseconds < 0) {
      return '0s';
    }
  
    const seconds = Math.round(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
  
    if (minutes === 0) {
      return `${remainingSeconds}s`;
    }
  
    if (remainingSeconds === 0) {
      return `${minutes}m`;
    }
  
    return `${minutes}m ${remainingSeconds}s`;
  };
 
  return (
    <KeyboardAvoidingView behavior="padding" style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back-outline" size={30} color="black" />
        </TouchableOpacity>
        <TouchableOpacity>
          <Ionicons name="videocam-outline" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageContainer}>
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <TouchableOpacity
                  key={docIndex}
                  style={styles.documentContainer}
                  onPress={() => openModal(document)}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {formatFileSize(document.size)}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))}
            {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Image
                  key={imgIndex}
                  source={{uri: image}}
                  style={styles.image}
                  resizeMode="cover"
                />
              ))}
            {message.text && (
              <Text style={styles.messageText}>{message.text}</Text>
            )}
          </View>
        ))}
        {audioMessages.map((audioMessage, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
            <View style={styles.audioProgressContainer}>
              <Slider
                style={styles.audioSlider}
                value={audioRecorderPlayer.currentPosition}
                maximumValue={audioRecorderPlayer.duration}
                minimumValue={0}
                minimumTrackTintColor="gray" //#DCF8c5
                maximumTrackTintColor="grey" //#BFBFBF
                thumbTintColor="#BFBFBF"
              />
            </View>
            <View style={styles.secondLineContainer}>
              <Text style={styles.audioDurationText}>
                {formatDuration(
                  Math.round(audioMessage.stop - audioMessage.start),
                )}
              </Text>
            </View>
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <TouchableOpacity
            key={index}
            style={styles.messageContainer}
            onPress={() => openModal(document)}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName} numberOfLines={1}>
                  {document.name.length > 20
                    ? document.name.substring(0, 15) + '...'
                    : document.name}
                </Text>
                <Text style={styles.documentSize}>
                  {formatFileSize(document.size)}
                </Text>
              </View>
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
      <Modal
        visible={isModalVisible}
        onRequestClose={() => setIsModalVisible(false)}
        transparent={true}>
        <TouchableOpacity
          style={styles.modalContainer}
          onPress={() => setIsModalVisible(false)}>
          {renderDocumentContent()}
        </TouchableOpacity>
      </Modal>
      {bottom && (
        <>
          <View style={styles.bottomboxone}>
            <TouchableOpacity
              style={styles.camerplusicon}
              onPress={usertextCamera}>
              <Ionicons
                name="camera"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Camera
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Gallery
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={pickDocument}>
              <Ionicons
                name="document-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Document
              </Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.Accountplusicon}>
              <MaterialCommunityIcons
                name="account-circle"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Tag Person
              </Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity
            style={styles.bottomboxtwo}
            onPress={Pluscancelbutton}>
            <Text style={styles.canceltext}>Cancel</Text>
          </TouchableOpacity>
        </>
      )}
      <View style={styles.inputContainer}>
        {!isKeyboardOpen && (
          <TouchableOpacity style={styles.cameraicon} onPress={usertextCamera}>
            <Ionicons name="camera" size={25} color="black" />
          </TouchableOpacity>
        )}
        <TextInput
          style={styles.textInput}
          placeholder="Type your message..."
          value={inputText}
          onChangeText={setInputText}
        />
        {isKeyboardOpen ? (
          <View style={{flexDirection: 'row'}}>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo
                name="plus"
                size={25}
                color="black"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={sendMessage}
              style={styles.sendiconbutton}
              disabled={inputText.trim().length === 0}>
              <Entypo name="paper-plane" size={30} color="black" />
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo name="plus" size={25} color="black" style={styles.icon} />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={isRecording ? stopRecording : startRecording}>
              <Ionicons
                name={isRecording ? 'stop' : 'mic-outline'}
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
            <TouchableOpacity onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
          </>
        )}
      </View>
      <Modal
        visible={showImagePreview}
        transparent={false}
        animationType="slide"
        onRequestClose={closeImagePreview}>
        <ImagePreviewScreen
          imageUrl={imageUrl}
          onClose={closeImagePreview}
          // onSendMessage={setInputText}
          navigation={navigation}
          // setImageUrl={setImageUrl}
        />
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  secondLineContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
    marginLeft: -70,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  contentContainer: {
    flexGrow: 1,
    backgroundColor: 'white',
  },
  messageContainer: {
    padding: 8,
    marginVertical: 4,
    borderTopLeftRadius: 15,
    borderBottomLeftRadius: 15,
    borderTopRightRadius: 10,
    borderBottomRightRadius: 0,
    backgroundColor: '#DCF8c5',
    maxWidth: '80%',
    alignSelf: 'flex-end',
    marginRight: 10,
    flexDirection: 'column',
  },
  image: {
    width: 300,
    height: 300,
    borderRadius: 8,
    marginTop: 8,
  },
  messageText: {
    fontSize: 16,
    color: 'black',
  },
  micplayicon: {
    color: 'gray',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'lightgray',
    padding: 10,
    backgroundColor: 'whitesmoke',
  },
  textInput: {
    height: 40,
    borderWidth: 1,
    width: '60%',
    borderColor: 'grey',
    borderRadius: 20,
    padding: 8,
    marginHorizontal: 5,
    // backgroundColor:"silver",
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  sendiconbutton: {
    padding: 10,
    marginLeft: 15,
  },
  icon: {
    marginHorizontal: 5,
  },
  iconss: {
    padding: 10,
  },
  plusIcon: {
    marginRight: 15,
  },
  bottomboxone: {
    width: '90%',
    height: 300,
    borderRadius: 20,
    backgroundColor: '#BFBFBF',
    position: 'absolute',
    bottom: 150,
    left: '5%',
    right: '5%',
  },
  bottomboxtwo: {
    width: '90%',
    height: 60,
    borderRadius: 20,
    position: 'absolute',
    bottom: 80,
    left: '5%',
    right: '5%',
    backgroundColor: '#BFBFBF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  canceltext: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'black',
  },
  camerplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 20,
    borderBottomLeftRadius: 0,
    borderTopRightRadius: 20,
    borderBottomRightRadius: 0,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  imageplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  Accountplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 20,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 20,
  },
  documentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#BFBFBF',
    padding: 10,
    borderRadius: 8,
    marginLeft: 8,
  },
  documentInfo: {
    marginLeft: 8,
  },
  documentName: {
    fontSize: 16,
    color: 'black',
  },
  documentSize: {
    fontSize: 12,
    color: 'black',
  },
  audioPlaybackContainer: {
    backgroundColor: '#DCF8c5',
    borderRadius: 8,
    padding: 10,
    marginRight: 8,
    alignSelf: 'flex-end',
    marginBottom: 10,
    flexDirection:"row"
  },
  audioSlider: {
    width: "60%",
    height: 20,
  },
  audioProgressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginVertical: 5,
  },
  audioProgressText: {
    color: '#BFBFBF',
    fontSize: 12,
  },
});

export default GlobalChatScreen;



            {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Image
                  key={imgIndex}
                  source={{uri: image}}
                  style={styles.image}
                  resizeMode="cover"
                />
              ))}

                          {/* {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Lightbox key={imgIndex} onOpen={toggleLightbox} onClose={toggleLightbox} >
                  <Image
                    source={{uri: image}}
                    style={styles.imageStyle}
                    resizeMode="cover"
                    useNativeDriver={false}
                  />
                </Lightbox>
              ))} */}

                    <Modal
        visible={isImageModalVisible}
        onRequestClose={() => setIsImageModalVisible(false)}
        transparent={true}>
        {selectedDocument && selectedDocument.uri ? (
          <View style={styles.fullScreenImageContainer}>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setIsImageModalVisible(false)}>
              <Ionicons name="close" size={30} color="white" />
            </TouchableOpacity>
            <Image
              source={{uri: selectedDocument.uri}}
              style={styles.fullScreenImage}
            />
          </View>
        ) : (
          <View>
            <Text>No document content available</Text>
          </View>
        )}
      </Modal>

                  {/* {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <Lightbox
                  key={imgIndex}
                  onOpen={() => toggleLightbox(image)}
                  onClose={() => toggleLightbox(null)}>
                  <Image
                    source={{uri: image}}
                    style={imageStyle}
                    resizeMode="cover"
                    useNativeDriver={false}
                  />
                </Lightbox>
              ))}
            {isInLightbox && (
              <Lightbox
                onOpen={() => toggleLightbox(currentImage)}
                onClose={() => toggleLightbox(null)}>
                <Image
                  source={{uri: currentImage}}
                  style={styles.fullWidthImage}
                  resizeMode="cover"
                  useNativeDriver={false}
                />
              </Lightbox>
            )} */}

                      // <View>
          //   <Image
          //     source={{uri: selectedDocument.uri}}
          //     style={styles.modalImage}
          //   />
          // </View>


            const toggleLightbox = image => {
    setCurrentImage(image);
    setIsInLightbox(!isInLightbox);
    setShowForwardIcon(!showForwardIcon);
  };

  const imageStyle = isInLightbox
    ? styles.fullWidthImage
    : {...styles.image, resizeMode: 'cover'};

    const renderLightboxContent = () => {
      if (currentImage) {
        return (
          <View>
            <Image
              source={{ uri: currentImage }}
              style={styles.fullWidthImage}
              resizeMode="cover"
              useNativeDriver={false}
            />
            {showForwardIcon && (
              <TouchableOpacity
                style={styles.forwardIconContainer}
                onPress={() => console.log("Forward icon clicked")}>
                <Entypo name="forward" color="white" size={30} />
              </TouchableOpacity>
            )}
          </View>
        );
      } else {
        return <Text>No image available</Text>;
      }
    };

    import Lightbox from 'react-native-lightbox';

      const [isInLightbox, setIsInLightbox] = useState(false);
  const [currentImage, setCurrentImage] = useState(null);
  const [showForwardIcon, setShowForwardIcon] = useState(false);



              {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <TouchableOpacity
                  key={imgIndex}
                  onPress={() => {
                    setSelectedImage(image);
                    setShowImageOverlay(true);
                  }}>
                  <Image
                    source={{uri: image}}
                    style={styles.image}
                    resizeMode="cover"
                  />
                </TouchableOpacity>
              ))}

                // const deleteImage = (imageToDelete) => {
  //   setMessages((prevMessages) => {
  //     const updatedMessages = [...prevMessages];
  //     const updatedMessage = updatedMessages.find((msg) => msg.image.includes(imageToDelete));
      
  //     if (updatedMessage) {
  //       updatedMessage.image = updatedMessage.image.filter((img) => img !== imageToDelete);
  //     }
  
  //     return updatedMessages;
  //   });
  // };

            // <View>
          //   <Image
          //     source={{uri: selectedDocument.uri}}
          //     style={styles.modalImage}
          //   />
          // </View>

          import React, {useState, useEffect, useRef} from 'react';

import React, {useState, useEffect, useRef} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  ScrollView,
  Keyboard,
  Image,
  Modal,
  Dimensions,
  PermissionsAndroid,
  Share,
  Button,
  Platform,
  LogBox,
  TouchableWithoutFeedback ,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';
import ImagePicker from 'react-native-image-crop-picker';
import ImagePreviewScreen from './ImagePreviewScreen';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import DocumentPicker from 'react-native-document-picker';
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import AudioRecorderPlayer from 'react-native-audio-recorder-player';
import {check, request, PERMISSIONS, RESULTS} from 'react-native-permissions';
import Slider from '@react-native-community/slider';
import RNFS from 'react-native-fs';
import {PinchGestureHandler, State} from 'react-native-gesture-handler';
import DocumentViewer from './DocumentViewer';
import AntDesign from "react-native-vector-icons/AntDesign"

LogBox.ignoreLogs([
  'Animated.event now requires a second argument for options',
]);
LogBox.ignoreLogs(['Animated: `useNativeDriver` was not specified']);
const audioRecorderPlayer = new AudioRecorderPlayer();
const {height, width} = Dimensions.get('window');

const GlobalChatScreen = ({route, navigation}) => {
  const [inputText, setInputText] = useState('');
  const [messages, setMessages] = useState([]);
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  const [showImagePreview, setShowImagePreview] = useState(false);
  const [bottom, setBottom] = useState(false);
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [selectedDocuments, setSelectedDocuments] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [audioUri, setAudioUri] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const [audioMessages, setAudioMessages] = useState([]);
  const [currentAudioIndex, setCurrentAudioIndex] = useState(null);
  const [audioRecordings, setAudioRecordings] = useState([]);
  const [selectedImage, setSelectedImage] = useState(null);
  const [showImageOverlay, setShowImageOverlay] = useState(false);
  const [pinIcon, setPinIcon] = useState();
  const [pinIconMessage, setpinIconMessage] = useState("");
  const [isMessageLongPressed, setIsMessageLongPressed] = useState(false);
  const [correctIcon, setcorrectIcon] = useState();
  const [messageTextStyle, setMessageTextStyle] = useState({
    padding: 8,
    marginVertical: 4,
    borderTopLeftRadius: 15,
    borderBottomLeftRadius: 15,
    borderTopRightRadius: 10,
    borderBottomRightRadius: 0,
    backgroundColor: '#DCF8c5',
    maxWidth: '80%',
    alignSelf: 'flex-end',
    marginRight: 10,
    flexDirection: 'column',
  });

  const changeMessageStyle = () => {
    const newStyles = {
      padding: 8,
      marginVertical: 4,
      borderTopLeftRadius: 15,
      borderBottomLeftRadius: 15,
      borderTopRightRadius: 10,
      borderBottomRightRadius: 0,
      backgroundColor: '#DCF8c5',
      maxWidth: '80%',
      alignSelf: 'flex-end',
      marginRight: 40,
      flexDirection: 'column',
    };
    setMessageTextStyle(newStyles);
  };

  const pinIcons = () => {
    setPinIcon(!pinIcon);
    setpinIconMessage(!pinIcon);

    setTimeout(() => {
      setpinIconMessage(false);
    },3000);
  }

  const correctIconChanging = () => {
    setcorrectIcon(!correctIcon);
  };

  const pinIconfunction = () => {
    pinIcons();
  }

  const handleLongPress = () => {
    setIsMessageLongPressed(!isMessageLongPressed);
    changeMessageStyle();
  };

  const handleLongPressCloseButton = () => {
    setIsMessageLongPressed(!isMessageLongPressed);
    setMessageTextStyle(!messageTextStyle)
  };

  useEffect(() => {
    const {image, text} = route.params || {};
    if (image || text) {
      const newMessage = {text, image: image || []};
      // const newMessage = {text, image: Array.isArray(image) ? image : [image]};
      setMessages([...messages, newMessage]);
    }
  }, [route.params]);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setIsKeyboardOpen(true);
      },
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setIsKeyboardOpen(false);
      },
    );
    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const sendMessage = () => {
    if (inputText || imageUrl || audioUri) {
      const newMessage = {
        text: inputText,
        image: imageUrl,
        audio: audioUri,
      };
      setMessages([...messages, newMessage]);
      setInputText('');
      setImageUrl('');
      setAudioUri('');
    }
  };

  const usertextCamera = async () => {
    try {
      const image = await ImagePicker.openCamera({
        compressImageMaxWidth: 500,
        compressImageMaxHeight: 500,
        cropping: true,
        compressImageQuality: 0.7,
      });
      console.log(image);
      if (image && image.path) {
        setImageUrl(image.path);
        setShowImagePreview(true);
        console.log('imageUrl:', imageUrl);
        console.warn('Image path is null or undefined.');
      }
    } catch (error) {
      console.error('Error picking image from camera:', error);
    }
  };

  const userGalleryOpen = () => {
    ImagePicker.openPicker({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      // cropping: true,
      multiple: true,
    }).then(images => {
      console.log(images);

      if (images && images.length > 0) {
        setImageUrl(images[0].path);
        setShowImagePreview(true);
      }
    });
  };

  const closeImagePreview = () => {
    setShowImagePreview(false);
  };

  const plusBotton = () => {
    setBottom(!bottom);
  };

  const Pluscancelbutton = async () => {
    setBottom(!bottom);
  };

  const pickDocument = async () => {
    try {
      const [result] = await DocumentPicker.pick({
        type: [DocumentPicker.types.allFiles],
      });

      console.log('Complete Document Result:', result);

      // Log specific properties to check their values
      console.log('Document Name:', result.name);
      console.log('Document Size (bytes):', result.size);
      console.log('Document URI:', result.uri);

      const newDocument = {
        name: result.name || 'Untitled',
        size: result.size || 0,
        uri: result.uri || 'Unknown URI',
        type: result.type || 'application/octet-stream',
      };

      setSelectedDocuments([...selectedDocuments, newDocument]);
      console.log('Selected documents updated:', selectedDocuments);
    } catch (err) {
      if (DocumentPicker.isCancel(err)) {
        console.log('Document picking cancelled');
      } else {
        console.error('Error picking document:', err);
      }
    }
  };

  const formatFileSize = sizeInBytes => {
    if (sizeInBytes < 1024) {
      return Math.round(sizeInBytes) + ' B';
    } else if (sizeInBytes < 1024 * 1024) {
      return Math.round(sizeInBytes / 1024) + ' KB';
    } else if (sizeInBytes < 1024 * 1024 * 1024) {
      return Math.round(sizeInBytes / (1024 * 1024)) + ' MB';
    } else {
      return Math.round(sizeInBytes / (1024 * 1024 * 1024)) + ' GB';
    }
  };

  const openModal = document => {
    setSelectedDocument(document);
    setIsModalVisible(true);
  };

  const renderDocumentContent = () => {
    if (selectedDocument && selectedDocument.uri) {
      if (selectedDocument.type && selectedDocument.type.startsWith('image/')) {
        // Displaying an image
        return (
          <DocumentViewer
            document={selectedDocument}
            onClose={() => setIsModalVisible(false)}
            navigation={navigation}
          />
        );
      } 
    } else {
      return <Text>No document content available</Text>;
    }
  };

  const startRecording = async () => {
    try {
      // Check audio recording permission
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);

      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio recording permission granted');

        // Start recording
        const result = await audioRecorderPlayer.startRecorder();
        setIsRecording(true);
        console.log(result);
      } else {
        console.log(
          'Audio recording permission not granted. Requesting permission...',
        );

        // Request audio recording permission
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );

        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio recording permission granted after request');

          // Start recording
          const result = await audioRecorderPlayer.startRecorder();
          setIsRecording(true);
          console.log(result);
        } else {
          console.log('Audio recording permission denied');
        }
      }
    } catch (error) {
      console.error('Error starting recording:', error);
    }
  };

  const stopRecording = async () => {
    try {
      const result = await audioRecorderPlayer.stopRecorder();
      setIsRecording(false);
      const startTimestamp = audioRecorderPlayer.currentTimestamp;
      const stopTimestamp = new Date().getTime();
      const durationInSeconds = Math.round(
        (stopTimestamp - startTimestamp) / 1000,
      ); 
      const formattedDuration = audioRecorderPlayer.mmssss(durationInSeconds);

      const newRecording = {
        uri: result,
        duration: formattedDuration,
        start: startTimestamp,
        stop: stopTimestamp,
      };

      setAudioRecordings([...audioRecordings, newRecording]);
      setAudioMessages([...audioMessages, newRecording]);

      console.log(result);
    } catch (error) {
      console.error('Error stopping recording:', error);
    }
  };

  const playRecording = async index => {
    try {
      const audioMessage = audioMessages[index];
      if (!audioMessage || !audioMessage.uri) {
        console.error('Audio message or URI is empty or undefined.');
        return;
      }
      const permissionResult = await check(PERMISSIONS.ANDROID.RECORD_AUDIO);
      if (permissionResult === RESULTS.GRANTED) {
        console.log('Audio permission granted');
        const result = await audioRecorderPlayer.startPlayer(audioMessage.uri);
        setCurrentAudioIndex(index);
        setIsPlaying(!isPlaying);
      } else {
        console.log('Audio permission not granted. Requesting permission...');
        const permissionRequestResult = await request(
          PERMISSIONS.ANDROID.RECORD_AUDIO,
        );

        if (permissionRequestResult === RESULTS.GRANTED) {
          console.log('Audio permission granted after request');
          const result = await audioRecorderPlayer.startPlayer(
            audioMessage.uri,
          );
          setCurrentAudioIndex(index);
          setIsPlaying(!isPlaying);
        } else {
          console.log('Audio permission denied');
        }
      }
    } catch (error) {
      console.error('Error playing recording:', error);
    }
  };

  useEffect(() => {
    return () => {
      audioRecorderPlayer.stopPlayer();
      audioRecorderPlayer.removeRecordBackListener();
      audioRecorderPlayer.removePlayBackListener();
    };
  }, []);

  const formatDuration = milliseconds => {
    if (isNaN(milliseconds) || milliseconds < 0) {
      return '0s';
    }

    const seconds = Math.round(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;

    if (minutes === 0) {
      return `${remainingSeconds}s`;
    }

    if (remainingSeconds === 0) {
      return `${minutes}m`;
    }

    return `${minutes}m ${remainingSeconds}s`;
  };

  const handleShare = async () => {
    try {
      await Share.share({
        message: 'ChatWorld',
        url: selectedImage.uri, 
        title: 'Document Sharing',
      });
    } catch (error) {
      console.error('Error sharing document:', error.message);
    }
  };

  const deleteImage = (imageToDelete) => {
    setMessages((prevMessages) => {
      const updatedMessages = prevMessages.map((msg) => {
        if (msg.image && msg.image.includes(imageToDelete)) {
          if (msg.image.length === 1) {
            return { ...msg, isDeleted: true };
          }
          const updatedImages = msg.image.filter((img) => img !== imageToDelete);
          const deletedImageMessage = { text: 'This image is deleted', isDeleted: true };
          return [
            ...updatedImages.map((img) => ({ image: [img], text: msg.text })),
            deletedImageMessage,
          ];
        }
        return msg;
      });
  
      return updatedMessages.flat(); 
    });
  };
  
  return (
    <KeyboardAvoidingView behavior="padding" style={styles.container}>
      {!isMessageLongPressed ? (
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back-outline" size={30} color="black" />
          </TouchableOpacity>
          <TouchableOpacity>
            <Ionicons name="videocam-outline" size={30} color="black" />
          </TouchableOpacity>
        </View>
      ) : (
        <View style={styles.header1}>
          <TouchableOpacity onPress={handleLongPressCloseButton}>
            <Ionicons name="close" size={30} color="black" />
          </TouchableOpacity>
          <View style={styles.rightIconsContainer}>
            <TouchableOpacity style={styles.iconButton}>
              <Entypo name="forward" color="black" size={25} />
            </TouchableOpacity>
            <TouchableOpacity style={styles.iconButton}>
              <Ionicons name="trash-outline" size={25} color="black" />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={pinIconfunction}
              style={styles.iconButton}>
              <AntDesign
                name={pinIcon ? 'pushpin' : 'pushpino'}
                size={25}
                color="black"
              />
            </TouchableOpacity>
            <TouchableOpacity >
              <AntDesign name="infocirlceo" color="black" size={25} />
            </TouchableOpacity>
          </View>
        </View>
      )}
      <ScrollView
        contentContainerStyle={styles.contentContainer}
        ref={scrollView => (this.scrollView = scrollView)}
        onContentSizeChange={() =>
          this.scrollView.scrollToEnd({animated: true})
        }>
        {messages.map((message, index) => (
          <View key={index} style={[styles.messageContainer, messageTextStyle]}>
            {message.documents &&
              message.documents.map((document, docIndex) => (
                <TouchableOpacity
                  key={docIndex}
                  style={styles.documentContainer}
                  onPress={() => openModal(document)}>
                  <FontAwesome name="file-text-o" size={20} color="white" />
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName}>{document.name}</Text>
                    <Text style={styles.documentSize}>
                      {formatFileSize(document.size)}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))}
            {message.image &&
              Array.isArray(message.image) &&
              message.image.map((image, imgIndex) => (
                <View key={imgIndex}>
                  {!message.isDeleted ? (
                    <TouchableOpacity
                      onPress={() => {
                        setSelectedImage(image);
                        setShowImageOverlay(true);
                      }}>
                      <Image
                        source={{uri: image}}
                        style={styles.image}
                        resizeMode="cover"
                      />
                    </TouchableOpacity>
                  ) : (
                    <Text style={{color: 'black', fontSize: 16}}>
                      This image is deleted
                    </Text>
                  )}
                </View>
              ))}
            <TouchableOpacity onLongPress={handleLongPress}>
              {message.text && (
                <Text style={styles.messageText}>{message.text}</Text>
              )}
            </TouchableOpacity>
            {isMessageLongPressed && (
              <TouchableOpacity
                onPress={correctIconChanging}
                style={styles.correctionIcon}>
                <AntDesign name={correctIcon ? "checkcircleo" : "checkcircle"} size={20} color={correctIcon ? "black" : "#1E90FF"} />
              </TouchableOpacity>
            )}
          </View>
        ))}
        {audioMessages.map((audioMessage, index) => (
          <View key={index} style={styles.audioPlaybackContainer}>
            <TouchableOpacity onPress={() => playRecording(index)}>
              <Ionicons
                name={
                  index === currentAudioIndex && isPlaying ? 'pause' : 'play'
                }
                size={30}
                color="#BFBFBF"
                style={styles.micplayicon}
              />
            </TouchableOpacity>
            <View style={styles.audioProgressContainer}>
              <Slider
                style={styles.audioSlider}
                value={audioRecorderPlayer.currentPosition}
                maximumValue={audioRecorderPlayer.duration}
                minimumValue={0}
                minimumTrackTintColor="gray" //#DCF8c5
                maximumTrackTintColor="grey" //#BFBFBF
                thumbTintColor="#BFBFBF"
              />
            </View>
            <View style={styles.secondLineContainer}>
              <Text style={styles.audioDurationText}>
                {formatDuration(
                  Math.round(audioMessage.stop - audioMessage.start),
                )}
              </Text>
            </View>
          </View>
        ))}
        {selectedDocuments.map((document, index) => (
          <TouchableOpacity
            key={index}
            style={styles.messageContainer}
            onPress={() => openModal(document)}>
            <View style={styles.documentContainer}>
              <FontAwesome name="file-text-o" size={20} color="black" />
              <View style={styles.documentInfo}>
                <Text style={styles.documentName} numberOfLines={1}>
                  {document.name.length > 20
                    ? document.name.substring(0, 15) + '...'
                    : document.name}
                </Text>
                <Text style={styles.documentSize}>
                  {formatFileSize(document.size)}
                </Text>
              </View>
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
      <Modal
        visible={isModalVisible}
        onRequestClose={() => setIsModalVisible(false)}
        transparent={true}>
        <TouchableOpacity
          style={styles.modalContainer}
          onPress={() => setIsModalVisible(false)}>
          {renderDocumentContent()}
        </TouchableOpacity>
      </Modal>
      {bottom && (
        <>
          <View style={styles.bottomboxone}>
            <TouchableOpacity
              style={styles.camerplusicon}
              onPress={usertextCamera}>
              <Ionicons
                name="camera"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Camera
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Gallery
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.imageplusicon}
              onPress={pickDocument}>
              <Ionicons
                name="document-outline"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Document
              </Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.Accountplusicon}>
              <MaterialCommunityIcons
                name="account-circle"
                size={30}
                color="black"
                style={{marginLeft: 25}}
              />
              <Text
                style={{
                  marginLeft: 15,
                  fontSize: 19,
                  fontWeight: '400',
                  color: 'black',
                }}>
                Tag Person
              </Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity
            style={styles.bottomboxtwo}
            onPress={Pluscancelbutton}>
            <Text style={styles.canceltext}>Cancel</Text>
          </TouchableOpacity>
        </>
      )}
      <View style={styles.inputContainer}>
        {!isKeyboardOpen && (
          <TouchableOpacity style={styles.cameraicon} onPress={usertextCamera}>
            <Ionicons name="camera" size={25} color="black" />
          </TouchableOpacity>
        )}
        <TextInput
          style={styles.textInput}
          placeholder="Type your message..."
          value={inputText}
          onChangeText={setInputText}
        />
        {isKeyboardOpen ? (
          <View style={{flexDirection: 'row'}}>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo
                name="plus"
                size={25}
                color="black"
                style={styles.sendiconbutton}
              />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={sendMessage}
              style={styles.sendiconbutton}
              disabled={inputText.trim().length === 0}>
              <Entypo name="paper-plane" size={30} color="black" />
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <TouchableOpacity onPress={plusBotton}>
              <Entypo name="plus" size={25} color="black" style={styles.icon} />
            </TouchableOpacity>
            <TouchableOpacity
              onPress={isRecording ? stopRecording : startRecording}>
              <Ionicons
                name={isRecording ? 'stop' : 'mic-outline'}
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
            <TouchableOpacity onPress={userGalleryOpen}>
              <Ionicons
                name="image-outline"
                size={25}
                color="black"
                style={styles.icon}
              />
            </TouchableOpacity>
          </>
        )}
      </View>
      <Modal
        visible={showImagePreview}
        transparent={false}
        animationType="slide"
        onRequestClose={closeImagePreview}>
        <ImagePreviewScreen
          imageUrl={imageUrl}
          onClose={closeImagePreview}
          // onSendMessage={setInputText}
          navigation={navigation}
          // setImageUrl={setImageUrl}
        />
      </Modal>
      <Modal
        visible={isModalVisible}
        onRequestClose={() => setIsModalVisible(false)}
        transparent={true}>
        <TouchableOpacity
          style={styles.modalContainer}
          onPress={() => setIsModalVisible(false)}>
          {renderDocumentContent()}
        </TouchableOpacity>
      </Modal>
      <Modal
        visible={showImageOverlay}
        transparent={true}
        onRequestClose={() => setShowImageOverlay(false)}>
        <View
          style={{
            flex: 1,
            backgroundColor: 'white',
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Image
            source={{uri: selectedImage}}
            style={styles.fullWidthImage}
            resizeMode="contain"
          />
          <View
            style={{
              position: 'absolute',
              flexDirection: 'row',
              top: 10,
              width: '100%',
              paddingHorizontal: 10,
              justifyContent: 'space-between',
            }}>
            <TouchableOpacity onPress={() => setShowImageOverlay(false)}>
              <Ionicons name="arrow-back-outline" size={30} color="black" />
            </TouchableOpacity>
            <TouchableOpacity>
              <Entypo name="forward" color="black" size={30} />
            </TouchableOpacity>
          </View>
          {pinIconMessage && (
            <View style={styles.pinIConview}>
              <Text style={{color: 'white'}}>This Message is Pined</Text>
            </View>
          )}
          <View
            style={{
              flexDirection: 'row',
              position: 'absolute',
              bottom: 20,
              justifyContent: 'space-between',
              width: '80%',
              paddingHorizontal: 20,
            }}>
            <TouchableOpacity onPress={handleShare}>
              <Ionicons name="share-outline" size={30} color="black" />
            </TouchableOpacity>
            <TouchableOpacity onPress={pinIconfunction}>
              <AntDesign
                name={pinIcon ? 'pushpin' : 'pushpino'}
                size={25}
                color="black"
              />
            </TouchableOpacity>
            <TouchableOpacity onPress={() => deleteImage(selectedImage)}>
              <Ionicons name="trash-outline" size={25} color="black" />
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  pinIConview: {
    flexDirection: 'row',
    position: 'absolute',
    bottom: 100,
    justifyContent: 'center',
    alignItems: 'center',
    width: '80%',
    paddingHorizontal: 20,
    backgroundColor: 'silver',
    height: 40,
    borderRadius: 20,
  },
  secondLineContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
    marginLeft: -70,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  header1:{
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    backgroundColor: 'lightgray',
  },
  contentContainer: {
    flexGrow: 1,
    backgroundColor: 'white',
  },
  messageContainer: {
    padding: 8,
    marginVertical: 4,
    borderTopLeftRadius: 15,
    borderBottomLeftRadius: 15,
    borderTopRightRadius: 10,
    borderBottomRightRadius: 0,
    backgroundColor: '#DCF8c5',
    maxWidth: '80%',
    alignSelf: 'flex-end',
    marginRight: 10,
    flexDirection: 'column',
  },
  image: {
    width: 300,
    height: 300,
    borderRadius: 8,
    marginTop: 8,
  },
  messageText: {
    fontSize: 16,
    color: 'black',
  },
  micplayicon: {
    color: 'gray',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'lightgray',
    padding: 10,
    backgroundColor: 'whitesmoke',
  },
  textInput: {
    height: 40,
    borderWidth: 1,
    width: '60%',
    borderColor: 'grey',
    borderRadius: 20,
    padding: 8,
    marginHorizontal: 5,
    // backgroundColor:"silver",
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  iconButton: {
    marginRight: 30, 
  },
  rightIconsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },  
  sendiconbutton: {
    padding: 10,
    marginLeft: 15,
  },
  icon: {
    marginHorizontal: 5,
  },
  iconss: {
    padding: 10,
  },
  plusIcon: {
    marginRight: 15,
  },
  bottomboxone: {
    width: '90%',
    height: 300,
    borderRadius: 20,
    backgroundColor: '#BFBFBF',
    position: 'absolute',
    bottom: 150,
    left: '5%',
    right: '5%',
  },
  bottomboxtwo: {
    width: '90%',
    height: 60,
    borderRadius: 20,
    position: 'absolute',
    bottom: 80,
    left: '5%',
    right: '5%',
    backgroundColor: '#BFBFBF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  canceltext: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'black',
  },
  camerplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 20,
    borderBottomLeftRadius: 0,
    borderTopRightRadius: 20,
    borderBottomRightRadius: 0,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  imageplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  Accountplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 20,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 20,
  },
  documentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#BFBFBF',
    padding: 10,
    borderRadius: 8,
    marginLeft: 8,
  },
  documentInfo: {
    marginLeft: 8,
  },
  documentName: {
    fontSize: 16,
    color: 'black',
  },
  documentSize: {
    fontSize: 12,
    color: 'black',
  },
  audioPlaybackContainer: {
    backgroundColor: '#DCF8c5',
    borderRadius: 8,
    padding: 10,
    marginRight: 8,
    alignSelf: 'flex-end',
    marginBottom: 10,
    flexDirection: 'row',
  },
  audioSlider: {
    width: '60%',
    height: 20,
  },
  audioProgressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginVertical: 5,
  },
  audioProgressText: {
    color: '#BFBFBF',
    fontSize: 12,
  },
  fullWidthImage: {
    width: width,
    height: '60%',
    resizeMode: 'cover',
  },
  correctionIcon: {
    position: 'absolute',
    top: 10, 
    right: -30, 
  },
});

export default GlobalChatScreen;


      {/* <Text style={styles.title}>Username</Text> */}
      {/* <View style={styles.buttonContainer}>
        <TouchableOpacity style={styles.button} onPress={handleStartVideoCall}>
          <FontAwesome6 name="video" size={30} color="white" />
          <Text style={styles.buttonText}>Start Video Call</Text>
        </TouchableOpacity>
      </View> */}


  // const handleLongPress = message => {
  //   setIsMessageLongPressed(!isMessageLongPressed);
  //   changeMessageStyle();
  //   setSelectedMessageId(message.id);
  // };

  // const handleLongPress = message => {
  //   setIsMessageLongPressed(!isMessageLongPressed);
  //   changeMessageStyle();
  //   setSelectedMessageId(message.id);
  // };

  // const handleIconPress = messageId => {
  //   setcorrectIcon(prev => !prev);
  //   setSelectedMessageId(messageId);
  //   setMessageIconStates(prevStates => ({
  //     ...prevStates,
  //     [messageId]: !prevStates[messageId],
  //   }));
  // };

  // const handleLongPress = (message) => {
  //   setIsMessageLongPressed(!isMessageLongPressed);
  //   changeMessageStyle();
  //   setSelectedMessageId(message.id);
  // };

  // const handleIconPress = (messageId) => {
  //   setMessageIconStates((prevStates) => {
  //     return {
  //       ...prevStates,
  //       [messageId]: !prevStates[messageId],
  //     };
  //   });
  // };

    // const handleIconPress = () => {
  //   setMessageIconStates(prevStates => ({
  //     ...prevStates,
  //     [selectedMessageId]: !prevStates[selectedMessageId],
  //   }));
  // };  

  // const handleIconPress = messageId => {
  //   setcorrectIcon(prev => !prev);
  //   setSelectedMessageId(messageId);
  // };


    // useEffect(() => {
  //   const keyboardDidShowListener = Keyboard.addListener(
  //     'keyboardDidShow',
  //     () => {
  //       setIsKeyboardOpen(true);
  //     },
  //   );
  //   const keyboardDidHideListener = Keyboard.addListener(
  //     'keyboardDidHide',
  //     () => {
  //       setIsKeyboardOpen(false);
  //     },
  //   );
  //   return () => {
  //     keyboardDidShowListener.remove();
  //     keyboardDidHideListener.remove();
  //   };
  // }, []);

          {/* {currentboth ? (
          <Video
            source={{uri: selectedVideo}}
            style={styles.video}
            controls={true}
            paused={true}
            resizeMode="contain"
          />
        ) : (
          <Image
            source={{uri: selectedThumbnail}}
            style={styles.image}
            resizeMode="cover"
          />
        )} */}


                {currentboth ? (
          <Video
            source={{uri: selectedVideo}}
            style={styles.video}
            controls={true}
            paused={true}
            resizeMode="contain"
          />
        ) : (
          <Image
            source={{uri: selectedThumbnail}}
            style={styles.image}
            resizeMode="cover"
          />
        )}


              <View style={styles.smallselectimgaeview}>
        <View style={styles.smallselectimageviewrow}>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator
            contentContainerStyle={styles.smallScrollView}>
            {/* Images */}
            <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
              <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
            </TouchableOpacity>
            {galleryImages
              .filter(media => !media.endsWith('.mp4'))
              .map((image, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(image)}>
                  <Image source={{uri: image}} style={styles.SelectedImage} />
                </TouchableOpacity>
              ))}

            {/* Videos */}
            {galleryImages
              .filter(media => media.endsWith('.mp4'))
              .map((video, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(video)}>
                  <Video
                    source={{uri: video}}
                    style={styles.SelectedImage}
                    paused={true}
                    resizeMode="cover"
                  />
                </TouchableOpacity>
              ))}
          </ScrollView>
        </View>
      </View>






      import React, {useState, useEffect} from 'react';
import {
  View,
  Image,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Dimensions,
  KeyboardAvoidingView,
  Keyboard,
  LogBox,
  ScrollView,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Entypo from 'react-native-vector-icons/Entypo';
import ImagePicker from 'react-native-image-crop-picker';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import Video from 'react-native-video-controls';

LogBox.ignoreLogs(['Image path is null or undefined']);

const {height, width} = Dimensions.get('window');

const ImagePreviewScreen = ({
  imageUrl,
  onClose,
  onSendMessage,
  navigation,
  route,
}) => {
  const [bottom, setBottom] = useState(false);
  const [inputText, setInputText] = useState('');
  const [galleryImages, setGalleryImages] = useState([]);
  const [selectedThumbnail, setSelectedThumbnail] = useState(imageUrl);
  const [selectedVideo, setSelectedVideo] = useState(null);
  const [currentboth, setCurrentboth] = useState();

  // const sendImage = () => {
  //   if (imageUrl || (galleryImages && galleryImages.length > 0) || inputText) {
  //     const newMessage = {
  //       text: inputText,
  //       image: imageUrl
  //         ? galleryImages
  //           ? [imageUrl, ...galleryImages]
  //           : [imageUrl]
  //         : galleryImages
  //           ? [...galleryImages]
  //           : [],
  //     };

  //     navigation.navigate('GlobalChatScreen', {
  //       image: newMessage.image,
  //       text: newMessage.text,
  //     });
  //     onClose();
  //   }
  // };

  const sendImage = () => {
    if (
      imageUrl ||
      (galleryImages && galleryImages.length > 0) ||
      inputText ||
      selectedVideo
    ) {
      const newMessage = {
        text: inputText,
        image: imageUrl
          ? galleryImages
            ? [imageUrl, ...galleryImages]
            : [imageUrl]
          : galleryImages
            ? [...galleryImages]
            : [],
        video: selectedVideo ? selectedVideo : null,
      };
      navigation.navigate('GlobalChatScreen', {
        image: newMessage.image,
        text: newMessage.text,
        video: newMessage.video,
      });
      onClose();
    }
  };

  const goBack = () => {
    onClose();
  };

  const plusBotton = () => {
    setBottom(!bottom);
  };

  const Pluscancelbutton = async () => {
    setBottom(!bottom);
  };

  const usertextCamera = async () => {
    ImagePicker.openCamera({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      multiple: true,
    }).then(images => {
      console.log(images);

      if (images && images.length > 0) {
        setGalleryImages(prevImages => [
          ...prevImages,
          ...images.map(image => image.path),
        ]);
      }
    });
  };

  // const userGalleryOpen = () => {
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 500,
  //     compressImageMaxHeight: 500,
  //     multiple: true,
  //   }).then(images => {
  //     console.log(images);
  //     if (images && images.length > 0) {
  //       setGalleryImages(prevImages => [
  //         ...prevImages,
  //         ...images.map(image => image.path),
  //       ]);
  //     }
  //   });
  // };

  //   const userGalleryOpen = () => {
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 500,
  //     compressImageMaxHeight: 500,
  //     multiple: true,
  //     mediaType: 'any',
  //   }).then(images => {
  //     console.log(images);
  //     if (images && images.length > 0) {
  //       setGalleryImages(prevImages => [
  //         ...prevImages,
  //         ...images.map(image => image.path),
  //       ]);
  //     };
  //     if (images && images.length > 0) {
  //       setSelectedVideo(images[0].path);
  //     }
  //   });
  // };

  const userGalleryOpen = () => {
    ImagePicker.openPicker({
      compressImageMaxWidth: 500,
      compressImageMaxHeight: 500,
      multiple: true,
      mediaType: 'any',
    }).then(media => {
      if (media && media.length > 0) {
        const video = media.find(
          item => item.mime && item.mime.startsWith('video/'),
        );
        if (video) {
          setSelectedVideo(video.path);
        } else {
          setGalleryImages(prevImages => [
            ...prevImages,
            ...media
              .filter(item => item.mime && item.mime.startsWith('image/'))
              .map(image => image.path),
          ]);
        }
      }
    });
  };

  const handleImageClick = selectedImage => {
    setSelectedThumbnail(selectedImage);
  };

  const cropAndRotateImage = async () => {
    try {
      const croppedImage = await ImagePicker.openCropper({
        path: selectedThumbnail,
        width: 300,
        height: 400,
        freeStyleCropEnabled: true,
      });
      setSelectedThumbnail(croppedImage.path);
    } catch (error) {
      console.log('Error cropping image:', error);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.headericons}>
        <TouchableOpacity onPress={goBack} style={styles.backButton}>
          <Ionicons name="arrow-back-outline" size={30} color="black" />
        </TouchableOpacity>
        <TouchableOpacity onPress={cropAndRotateImage}>
          <MaterialCommunityIcons name="crop-rotate" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <View style={styles.bothimageandvideo}>
        {selectedVideo ? (
          <Video
            source={{uri: selectedVideo}}
            style={styles.video}
            controls={true}
            paused={true}
            resizeMode="contain"
          />
        ) : (
          <Image
            source={{uri: selectedThumbnail}}
            style={styles.image}
            resizeMode="cover"
          />
        )}
      </View>
      {/* <View style={styles.smallselectimgaeview}>
        <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
          <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
        </TouchableOpacity>
        {galleryImages.map((thumbnailImage, index) => (
          <TouchableOpacity
            key={index}
            onPress={() => handleImageClick(thumbnailImage)}>
            <Image
              source={{uri: thumbnailImage}}
              style={styles.SelectedImage}
            />
          </TouchableOpacity>
        ))}
      </View> */}

      <View style={styles.smallselectimgaeview}>
        <View style={styles.smallselectimageviewrow}>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator
            contentContainerStyle={styles.smallScrollView}>
            {/* Images */}
            <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
              <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
            </TouchableOpacity>
            {galleryImages
              .filter(media => !media.endsWith('.mp4'))
              .map((image, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(image)}>
                  <Image source={{uri: image}} style={styles.SelectedImage} />
                </TouchableOpacity>
              ))}

            {/* Videos */}
            {galleryImages
              .filter(media => media.endsWith('.mp4'))
              .map((video, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(video)}>
                  <Video
                    source={{uri: video}}
                    style={styles.SelectedImage}
                    paused={true}
                    resizeMode="cover"
                  />
                </TouchableOpacity>
              ))}
          </ScrollView>
        </View>
      </View>

      <KeyboardAvoidingView
        behavior="padding"
        style={styles.rowcontentContainer}>
        {bottom && (
          <>
            <View style={styles.bottomboxone}>
              <TouchableOpacity
                style={styles.camerplusicon}
                onPress={usertextCamera}>
                <Ionicons
                  name="camera"
                  size={30}
                  color="black"
                  style={{marginLeft: 25}}
                />
                <Text
                  style={{
                    marginLeft: 15,
                    fontSize: 19,
                    fontWeight: '400',
                    color: 'black',
                    fontSize: 19,
                    fontWeight: '400',
                    color: 'black',
                  }}>
                  Camera
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.imageplusicon}
                onPress={userGalleryOpen}>
                <Ionicons
                  name="image-outline"
                  size={30}
                  color="black"
                  style={{marginLeft: 25}}
                />
                <Text
                  style={{
                    marginLeft: 15,
                    fontSize: 19,
                    fontWeight: '400',
                    color: 'black',
                  }}>
                  Add Photo
                </Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.Accountplusicon}>
                <MaterialCommunityIcons
                  name="account-circle"
                  size={30}
                  color="black"
                  style={{marginLeft: 25}}
                />
                <Text
                  style={{
                    marginLeft: 15,
                    fontSize: 19,
                    fontWeight: '400',
                    color: 'black',
                  }}>
                  Tag Person
                </Text>
              </TouchableOpacity>
            </View>
            <TouchableOpacity
              style={styles.bottomboxtwo}
              onPress={Pluscancelbutton}>
              <Text style={styles.canceltext}>Cancel</Text>
            </TouchableOpacity>
          </>
        )}
        <View style={styles.rowcontent}>
          <TouchableOpacity style={styles.cameraicon} onPress={plusBotton}>
            <Entypo name="plus" size={25} color="black" />
          </TouchableOpacity>
          <TextInput
            style={styles.input}
            placeholder="Type your message..."
            value={inputText}
            onChangeText={setInputText}
          />
          <TouchableOpacity style={styles.sendButton} onPress={sendImage}>
            <Ionicons name="paper-plane" size={24} color="grey" />
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: width,
    height: height,
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
  },
  rowcontentContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    alignItems: 'center',
    marginBottom: 50,
  },
  image: {
    width: width,
    height: '60%',
    // marginTop: -20,
  },
  video: {
    width: width,
    height: '60%',
    // marginTop: -20,
  },
  bothimageandvideo: {
    width: width,
    height: '60%',
    marginTop: -20,
    justifyContent: 'center',
  },
  input: {
    height: 40,
    borderWidth: 1,
    width: '65%',
    borderColor: 'grey',
    borderRadius: 20,
    padding: 8,
    marginVertical: 10,
    backgroundColor: 'white',
    marginLeft: 5,
    color: 'black',
  },
  sendButton: {
    backgroundColor: '#DCF8c5',
    borderRadius: 30,
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
  },
  rowcontent: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 10,
  },
  backButton: {
    // position: 'absolute',
    // top: 20,
    // left: 20,
    // zIndex: 1,
  },
  bottomboxone: {
    width: '90%',
    height: 230,
    borderRadius: 20,
    backgroundColor: '#BFBFBF',
    // position: 'absolute',
    bottom: 10,
    left: '0%',
    right: '5%',
  },
  bottomboxtwo: {
    width: '90%',
    height: 60,
    borderRadius: 20,
    // position: 'absolute',
    bottom: 0,
    left: '0%',
    right: '5%',
    backgroundColor: '#BFBFBF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  canceltext: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'black',
  },
  camerplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 20,
    borderBottomLeftRadius: 0,
    borderTopRightRadius: 20,
    borderBottomRightRadius: 0,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  imageplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderBottomWidth: 1,
    borderBottomColor: 'grey',
  },
  Accountplusicon: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    // backgroundColor: 'pink',
    height: 75,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 20,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 20,
  },
  documentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#BFBFBF',
    padding: 10,
    borderRadius: 8,
    marginLeft: 8,
  },
  documentInfo: {
    marginLeft: 8,
  },
  documentName: {
    fontSize: 16,
    color: 'black',
  },
  documentSize: {
    fontSize: 12,
    color: 'black',
  },
  SelectedImage: {
    width: 50,
    height: 50,
    marginRight: 10,
  },
  smallselectimgaeview: {
    width: width,
    marginTop: 10,
    // flexDirection: 'row',
  },
  smallselectimageviewrow: {
    alignItems: 'center',
  },
  headericons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: width,
    paddingHorizontal: 20,
    position: 'absolute',
    top: 30,
  },
  cameraicon: {
    backgroundColor: 'violet',
    borderRadius: 20,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 5,
  },
  smallselectimgaeviewContainer: {
    alignItems: 'center',
  },
  smallScrollView: {
    flexDirection: 'row',
    width: '90%',
    justifyContent: 'center',
  },
});

export default ImagePreviewScreen;


      <View style={styles.smallselectimgaeview}>
        <View style={styles.smallselectimageviewrow}>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator
            contentContainerStyle={styles.smallScrollView}>
            {/* Images */}
            <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
              <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
            </TouchableOpacity>
            {galleryImages
              .filter(media => !media.endsWith('.mp4'))
              .map((image, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(image)}>
                  <Image source={{uri: image}} style={styles.SelectedImage} />
                </TouchableOpacity>
              ))}

            {/* Videos */}
            {galleryImages
              .filter(media => media.endsWith('.mp4'))
              .map((video, index) => (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleImageClick(video)}>
                  <Video
                    source={{uri: video}}
                    style={styles.SelectedImage}
                    paused={true}
                    resizeMode="cover"
                  />
                </TouchableOpacity>
              ))}
          </ScrollView>
        </View>
      </View>


            {/* <View style={styles.smallselectimgaeview}>
        <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
          <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
        </TouchableOpacity>
        {galleryImages.map((thumbnailImage, index) => (
          <TouchableOpacity
            key={index}
            onPress={() => handleImageClick(thumbnailImage)}>
            <Image
              source={{uri: thumbnailImage}}
              style={styles.SelectedImage}
            />
          </TouchableOpacity>
        ))}
      </View> */}

        // const userGalleryOpen = () => {
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 500,
  //     compressImageMaxHeight: 500,
  //     multiple: true,
  //   }).then(images => {
  //     console.log(images);
  //     if (images && images.length > 0) {
  //       setGalleryImages(prevImages => [
  //         ...prevImages,
  //         ...images.map(image => image.path),
  //       ]);
  //     }
  //   });
  // };

  //   const userGalleryOpen = () => {
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 500,
  //     compressImageMaxHeight: 500,
  //     multiple: true,
  //     mediaType: 'any',
  //   }).then(images => {
  //     console.log(images);
  //     if (images && images.length > 0) {
  //       setGalleryImages(prevImages => [
  //         ...prevImages,
  //         ...images.map(image => image.path),
  //       ]);
  //     };
  //     if (images && images.length > 0) {
  //       setSelectedVideo(images[0].path);
  //     }
  //   });
  // };

    // const sendImage = () => {
  //   if (imageUrl || (galleryImages && galleryImages.length > 0) || inputText) {
  //     const newMessage = {
  //       text: inputText,
  //       image: imageUrl
  //         ? galleryImages
  //           ? [imageUrl, ...galleryImages]
  //           : [imageUrl]
  //         : galleryImages
  //           ? [...galleryImages]
  //           : [],
  //     };

  //     navigation.navigate('GlobalChatScreen', {
  //       image: newMessage.image,
  //       text: newMessage.text,
  //     });
  //     onClose();
  //   }
  // };

          <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.smallScrollView}>
          {/* Images */}
          <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
            <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
          </TouchableOpacity>
          {galleryImages
            .filter(media => !media.endsWith('.mp4'))
            .map((image, index) => (
              <TouchableOpacity
                key={index}
                onPress={() => handleImageClick(image)}>
                <Image source={{uri: image}} style={styles.SelectedImage} />
              </TouchableOpacity>
            ))}
          {/* Videos */}
          {galleryImages
            .filter(media => media.endsWith('.mp4'))
            .map((video, index) => (
              <TouchableOpacity
                key={index}
                onPress={() => handleImageClick(video)}>
                <Video
                  source={{uri: video}}
                  style={styles.VideoThumbnail} 
                  paused={true}
                  resizeMode="cover"
                />
              </TouchableOpacity>
            ))}
        </ScrollView>


              {/* <View style={styles.smallselectimgaeview}>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.smallScrollView}>
          <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
            <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
          </TouchableOpacity>
          {galleryImages
            .filter(media => !media.endsWith('.mp4'))
            .map((image, index) => (
              <TouchableOpacity
                key={index}
                onPress={() => handleImageClick(image)}>
                <Image source={{uri: image}} style={styles.SelectedImage} />
              </TouchableOpacity>
            ))}
          {galleryImages
            .filter(media => media.endsWith('.mp4'))
            .map((video, index) => (
              <TouchableOpacity
                key={index}
                onPress={() => handleImageClick(video)}>
                <Video
                  source={{uri: video}}
                  style={styles.VideoThumbnail}
                  paused={true}
                  resizeMode="cover"
                />
              </TouchableOpacity>
            ))}
        </ScrollView>
      </View> */}


            <View style={styles.smallselectimgaeview}>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.smallScrollView}>
          {/* Images and Video Thumbnails */}
          <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
            <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
          </TouchableOpacity>
          {galleryImages.map((media, index) => (
            <TouchableOpacity
              key={index}
              onPress={() => handleImageClick(media)}>
              {media.endsWith('.mp4') ? (
                // For videos, show a placeholder image
                <Image
                  source={require('../Images/backgroundImage.jpg')}
                  style={styles.VideoThumbnail}
                />
              ) : (
                // For images, show the actual image
                <Image source={{uri: media}} style={styles.SelectedImage} />
              )}
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

                <TouchableOpacity style={styles.icon} onPress={ChatScreenFun}>
            <Ionicons
              name="chatbubble-ellipses-outline"
              size={30}
              color="black"
            />
          </TouchableOpacity>

                  <TouchableOpacity onPress={accountButton}>
          <MaterialCommunityIcons
            name={Account ? 'account-circle' : 'account-circle-outline'}
            size={30}
            color="black"
          />
        </TouchableOpacity>

            // borderTopLeftRadius: 45,
    // borderBottomLeftRadius: 0,
    // borderTopRightRadius: 45,
    // borderBottomRightRadius: 0,


    import {
  View,
  Text,
  Image,
  Alert,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ImageBackground,
  Linking,
  Platform,
  Modal,
} from 'react-native';
import React, {useState} from 'react';
import {Dimensions} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Fontisto from 'react-native-vector-icons/Fontisto';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import FontAwesome from 'react-native-vector-icons/FontAwesome';

const {height, width} = Dimensions.get('window');

const MainPages = ({navigation}) => {
  const [reels, setReels] = useState(false);
  const [search, setSearch] = useState(false);
  const [Home, setHome] = useState(false);
  const [Account, setAccount] = useState(false);

  const GlobalScreenbutton = () => {
    navigation.navigate('GlobalChatScreen');
  };

  const ReelsButton = () => {
    if (!reels) {
      setReels(true);
      setSearch(false);
      setHome(false);
      setAccount(false);
    }
  };

  const searchButton = () => {
    if (!search) {
      setSearch(true);
      setReels(false);
      setHome(false);
      setAccount(false);
    }
  };

  const HomeButton = () => {
    if (!Home) {
      setHome(true);
      setSearch(false);
      setReels(false);
      setAccount(false);
    }
  };

  const accountButton = () => {
    if (!Account) {
      setAccount(true);
      setSearch(false);
      setReels(false);
      setHome(false);
    }
  };

  const ChatScreenFun = () => {
    navigation.navigate('ChatScreenPage');
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.Chattext}>𝒞𝒽𝒶𝓉𝒲𝑜𝓇𝓁𝒹</Text>
        <TouchableOpacity>
          <Ionicons name="search-outline" size={30} color="black" />
        </TouchableOpacity>
      </View>
      <View style={styles.bottomBox}>
        <View style={styles.iconContainer}>
          <TouchableOpacity onPress={HomeButton}>
            <View style={styles.iconTextContainer}>
              <Ionicons
                name={Home ? 'chatbubbles-sharp' : 'chatbubbles-outline'}
                size={30}
                color={Home ? '#007FFF' : 'black'}
              />
              <Text
                style={[styles.smallText, {color: Home ? 'black' : 'gray'}]}>
                Chats
              </Text>
            </View>
          </TouchableOpacity>
          <TouchableOpacity onPress={ReelsButton}>
            <View style={styles.iconTextContainer}>
              <Ionicons
                name={reels ? 'heart-sharp' : 'heart-outline'}
                size={30}
                color={reels ? 'red' : 'black'}
              />
              <Text
                style={[styles.smallText, {color: reels ? 'black' : 'gray'}]}>
                Storys
              </Text>
            </View>
          </TouchableOpacity>
          <TouchableOpacity onPress={GlobalScreenbutton} style={styles.icon}>
            <View style={styles.iconTextContainer}>
              <Fontisto
                name="world-o"
                size={30}
                color="black"
              />
              <Text
                style={[styles.smallText, {color: Account ? 'black' : 'gray'}]}>
                GlobalChat
              </Text>
            </View>
          </TouchableOpacity>
          <TouchableOpacity onPress={searchButton}>
            <View style={styles.iconTextContainer}>
              <MaterialCommunityIcons
                name={search ? 'account-circle' : 'account-circle-outline'}
                size={30}
                color="black"
              />
              <Text
                style={[styles.smallText, {color: search ? 'black' : 'gray'}]}>
                Account
              </Text>
            </View>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: width,
    height: height,
    backgroundColor:"whitesmoke",
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    height: 60,
    borderBottomWidth: 0.5, 
    borderBottomColor: 'grey', 
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: {width: 1, height: 1},
    textShadowRadius: 2,
  },
  Chattext: {
    fontFamily: Platform.OS === 'android' ? 'YourCustomFontName' : 'Times New Roman',
    color: 'black',
    fontSize: 20,
    fontWeight: 'bold',
    width: 200,
  },
  iconContainer: {
    flexDirection: 'row',
  },
  icon: {
    marginHorizontal: 10,
  },
  bottomBox: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    position: 'absolute',
    bottom: 20,
    width: '90%',
    padding: 16,
    backgroundColor: 'white',
    borderRadius: 30,
    left: '5%',
    right: '5%',
    borderWidth: 0.5,  
    borderColor: 'lightgray', 
  },
  iconTextContainer: {
    alignItems: 'center',
    marginRight: 15,
    marginLeft: 15,
  },
  smallText: {
    fontSize: 12,
    marginTop: 5,
  },
});

export default MainPages;


  // const userGalleryOpen = () => {
  //   ImagePicker.openPicker({
  //     compressImageMaxWidth: 500,
  //     compressImageMaxHeight: 500,
  //     // cropping: true,
  //     multiple: true,
  //   }).then(images => {
  //     console.log(images);

  //     if (images && images.length > 0) {
  //       setImageUrl(images[0].path);
  //       setShowImagePreview(true);
  //     }
  //   });
  // }; 

    // const sendImage = () => {
  //   if (
  //     imageUrl ||
  //     (galleryImages && galleryImages.length > 0) ||
  //     inputText ||
  //     selectedVideo
  //   ) {
  //     const newMessage = {
  //       text: inputText,
  //       image: imageUrl
  //         ? galleryImages
  //           ? [imageUrl, ...galleryImages]
  //           : [imageUrl]
  //         : galleryImages
  //           ? [...galleryImages]
  //           : [],
  //       video: selectedVideo ? selectedVideo : null,
  //     };
  //     navigation.navigate('GlobalChatScreen', {
  //       image: newMessage.image,
  //       text: newMessage.text,
  //       video: newMessage.video,
  //     });
  //     onClose();
  //   }
  // };

            // Extract and set video thumbnail
          createThumbnail({
            url: video.path,
            timeStamp: 10000, // or a time you desire
          })
            .then(response => {
              setSelectedVideoThumbnail({uri: response.path});
            })
            .catch(error => console.error(error));


                    <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.smallScrollView}>
          {/* Images and Video Thumbnails */}
          {imageUrl && (
            <TouchableOpacity onPress={() => handleImageClick(imageUrl)}>
              <Image source={{uri: imageUrl}} style={styles.SelectedImage} />
            </TouchableOpacity>
          )}
          {galleryImages.map((media, index) => (
            <TouchableOpacity
              key={index}
              onPress={() => handleImageClick(media)}>
              {media.endsWith('.mp4') ? (
                // For videos, show the video without thumbnail
                <Video
                  source={{uri: media}}
                  style={styles.VideoThumbnail}
                  controls={true}
                  paused={true}
                  resizeMode="contain"
                />
              ) : (
                // For images, show the actual image
                <Image source={{uri: media}} style={styles.SelectedImage} />
              )}
            </TouchableOpacity>
          ))}
        </ScrollView>

                    {/* {message.video && (
              <Video
                source={{uri: message.video}}
                style={{width: 250, height: 250}}
                controls
              />
            )} */}


                  {/* {fullScreenVideoUrl && (
        <FullScreenVideoPlayer
          videoUrl={fullScreenVideoUrl}
          onClose={closeFullScreenVideo}
        />
      )} */}